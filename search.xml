<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[项目自检清单]]></title>
    <url>%2F2019%2F12%2F06%2F%E9%A1%B9%E7%9B%AE%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[项目自检清单1.01.1 NSCS项目配置webpack配置采用了下面几个loader，loader的作用就是相当于转译器，webpack无法读取除了js以外的任何文件，loader的作用就是为了将其他文件转换为webpack可以读取的文件 next-less next-css file-loader url-loader style-loader plugin，plugin相当于是webpack的扩展器，主要是监听webpack的生命周期中的某一个钩子来触发某一些操作，比如监听打包过程中最后的emit来选择输出文件 monaco-editor-webpack-plugin（我也不知道这个是什么鬼）nextnext各种基础配置项目搭建以及带来的副作用 服务端渲染后根据路由切成了多个html导致原来在SPA中的redux无法使用，通过看官方issue里面提供的解决方法(装redux-persist)就是将redux数据放入local storage里面。个人感觉不是太好 文件名即路由的问题，需要设置自定义路由，因为根据我的命名习惯会出现/home/home这种极其不符合常理的操作 现在仍无法使用getInitialProps来初始化组件的props 动态导入。因为无法直接操作dom，有一些包在导入的时候需要window对象但是在组件挂载的时候并没有生成dom，所以需要动态导入。import dynamic from &#39;next/dynamic&#39;通过它去自定义组件加载的时机 怎么去部署，因为路由拦截也是在前端做的redux1.2 sacc-cli1.3 PatentMiner1.4 Sacc-Homepage]]></content>
      <categories>
        <category>软件能</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试前的自检清单]]></title>
    <url>%2F2019%2F11%2F28%2F%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[面试前的自检清单1.01.1事件循环众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，用户引擎必须使用 event loops，也就是事件循环。 任务队列首先介绍一下什么是任务队列，对于一个单线程语言来说执行代码顺序是由任务队列来决定的，同步任务都会被放到主线程中执行。在代码运行到那一块的时候首先会去创建一个新的执行环境然后把这个执行环境推入执行栈顶部，同样如果在函数中又调用了其他函数那么发生同样的事情再创建一个新的执行环境并推入栈顶，浏览器始终处于栈顶的执行环境之中，执行完之后自动出栈。这就是同步任务执行的过程。那么异步任务是怎么执行的呢？同步任务是按执行栈的顺序来执行，异步任务委托给了其他浏览器的线程执行，执行有了结果后进入等待状态(等待进入执行栈)，在任务队列中存放的是这些异步函数的执行状态，只有当异步任务执行完以后才可以进行回调，而任务队列就是维护异步任务回调函数的队列，它会等到同步任务执行完以后再按照先进先出的顺序进行执行，执行过程中先去执行微任务再去执行宏任务，这样一轮事件循环就结束了，异步任务执行完以后会再进入下一个事件循环。任务队列主要是针对于异步任务的。 浏览器事件循环在知道了任务队列之后，我们知道异步任务有了回调结果之后会进入任务队列等待，但是任务队列仍然分为两种，一种是微任务，另外一种是宏任务。那么什么是微任务？什么是宏任务呢？ 微任务：Promises(浏览器实现的原生Promise)、MutationObserver、process.nextTick等宏任务：setTimeout、setInterval、setImmediate、I/O、UI rendering等PS:script(整体代码)即一开始在主执行栈中的同步代码本质上也属于宏任务，属于第一个执行的task 那么在这个循环中是优先执行同步任务，然后对于异步任务来说先执行微任务再执行宏任务，举个栗子：1234567891011121314151617console.log(1);setTimeout(function() &#123; console.log(2);&#125;, 0);new Promise(function(resolve,reject)&#123; console.log(3) resolve()&#125;).then(function() &#123; console.log(4);&#125;).then(function() &#123; console.log(5);&#125;);console.log(6);//1 - 3 - 6 - 4 - 5 - 2 从上面这个例子很清晰的可以看出先执行了一遍同步部分后执行微任务(Promise.then(...))再执行宏任务(setTimeout(...))，但是如果在微任务中嵌套宏任务又是怎么样的执行顺序呢？举个栗子： 123456789101112131415161718console.log(1)setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;, 0); new Promise((resolve) =&gt; &#123; console.log(4); resolve();&#125;).then(() =&gt; &#123; console.log(5); setTimeout(() =&gt; console.log(6), 0)&#125;); console.log(7); 1 - 4 - 7是同步任务执行完了，5 - 2是第一遍事件循环，3 - 6是二次循环。以上就是浏览器事件循环的全部内容了，接下来是Node的事件循环。 Node中的事件循环Node中的事件循环相对于浏览器的事件循环来说多了几个步骤，但是相对于执行顺序来讲只是多了两个函数的区别，首先说一说这六个阶段 timer（定时器）：本阶段执行已经被setTimeout()和 setInterval() 的调度回调函数 pending callbacks (待定回调)：执行延迟到下一个循环迭代的 I/O 回调。 idle,prepare：仅系统内部使用。 poll（轮询）：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 check（检测）：setImmediate() 回调函数在这里执行。 close callbacks(关闭的回调函数):一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。 执行顺序process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。也就是说process.nextTick方法相当于插队，setImmediate方法总是在check阶段执行。那么process.nextTick方法相对于promise.then来说更加优先。在一轮事件循环中setImmediate方法在setTimeout之前。 1.2闭包 继承(组合式、寄生式、组合寄生式)闭包实现静态私有变量打印自身执行次数的函数12345678910function helper()&#123; let i = 0; return function()&#123; i++; console.log(i) &#125;&#125;let foo = helper()var a = foo()var b = foo() 实现类1234567891011121314151617var Book = (function ()&#123; var bookNum = 0; function getBookNum()&#123;console.log(bookNum)&#125; function _book(id,name,priceNums)&#123; this.id = id; this.name = name; this.priceNums = priceNums; this.getName = function ()&#123;console.log(this.name)&#125; this.getId = function ()&#123;console.log(this.id)&#125; this.getPriceNums = function ()&#123;console.log(this.priceNums)&#125; &#125; _book.prototype = &#123; display:function ()&#123;console.log(&apos;display&apos;)&#125; &#125; return _book&#125;)()var a = new Book(1,&apos;a&apos;,200) 继承类式继承直接将对象的prototype指向一个父类的实例123456789101112131415function Father(name,lastName)&#123; this.name = name; this.lastName = lastName; this.like = [1,2,3]&#125;Father.prototype.getLastName = function()&#123; console.log(this.lastName)&#125;function Son(name)&#123; this.name = name;&#125; Son.prototype = new Father(&apos;a&apos;,&apos;b&apos;)Son.prototype.getName = function()&#123; console.log(this.name)&#125; 这样做有两个缺点，一是由于之类通过原型prototype对父类进行实例化继承父类。所以父类中共有的属性如果是引用类型那么就会在所有子类中被共用，在修改的同时会产生一些不可避免的副作用。二是由于是使用prototype继承的父类所以无法向父类传递参数，实例化的时候也无法对父类的构造函数进行初始化。 构造函数继承构造函数继承就是如字面意思一样直接把继承放到构造函数中进行123456789101112131415function Father(name,lastName)&#123; this.name = name; this.lastName = lastName; this.like = [1,2,3]&#125;Father.prototype.getLastName = function()&#123; console.log(this.lastName)&#125;function Son(name,lastName)&#123; this.name = name; Father.call(this,lastName)&#125; Son.prototype.getName = function()&#123; console.log(this.name)&#125; 这样做的坏处也十分明显，父类直接覆盖了子类属性同时父类的一些共有方法是放在prototype上的，这样做因为没有涉及到原型prototype所以无法使用，违背了设计原理 组合继承前两种方式都有着自己的缺点，类式继承是无法输入父类参数和更改父类引用类型数据的时候会出现副作用，构造函数继承是会覆盖和无法使用父类共有方法，那么将两者结合的话是否就可以了12345678910111213141516function Father(name,lastName)&#123; this.name = name; this.lastName = lastName; this.like = [1,2,3]&#125;Father.prototype.getLastName = function()&#123; console.log(this.lastName)&#125;function Son(name,lastName)&#123; Father.call(this,&apos;&apos;,lastName) this.name = name;&#125;Son.prototype = new Father() Son.prototype.getName = function()&#123; console.log(this.name)&#125; 虽然这种方法看起来规避了所有的缺点，但是由于是两种方法的结合所以在子类的构造函数里执行了一次父类的构造函数，在prototype实例化父类的时候也执行了一次父类的构造函数 原型式继承这种方法类似于类式继承同样也存在和类式继承同样的问题，更改父类引用类型变量的时候会引起副作用1234567891011121314function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125;function Father(name,lastName)&#123; this.name = name; this.lastName = lastName; this.like = [1,2,3]&#125;Father.prototype.getLastName = function()&#123; console.log(this.lastName)&#125;var a = inheritObject(Father(1,2)) 封装了一个方法通过空对象去继承 寄生式继承这种方法是对原型式继承的扩充，规避了它的缺点，同时去扩展这个对象123456789101112function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125;function createSon(obj)&#123; var o = new inheritObject(obj); o.getLastName = function ()&#123; console.log(lastName) &#125; return o&#125; 寄生组合式继承寄生+组合，完美1234567891011121314151617181920212223242526function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(father,son)&#123; var p = new inheritObject(father.prototype) p.constructor = son son.prototype = p&#125;function Father(name,lastName)&#123; this.name = name; this.lastName = lastName; this.like = [1,2,3]&#125;Father.prototype.getLastName = function()&#123; console.log(this.lastName)&#125;function Son(name,lastName)&#123; Father.call(this,name,lastName) this.name = name;&#125;inheritPrototype(Father,Son)Son.prototype.getName = function()&#123; console.log(this.name)&#125; 多继承属性复制 1.3cookie||session||token区别cookie由服务端生成，发送给浏览器，保存在本地浏览器上的数据，用来识别用户信息的一个键值对，每一次发送请求的时候都会带上cookie发送给服务器。内容大小不超过4KB。优点： 简单性。Cookie 是一种基于文本的轻量结构，包含简单的键值对。 不需要任何服务器资源 Cookie 存储在客户端并在发送后由服务器读取。 可配置到期规则 Cookie 可以在浏览器会话结束时到期，或者可以在客户端计算机上无限期存在，这取决于客户端的到期规则。 缺点： 大小受到限制 潜在的安全风险 Cookie 可能会被篡改。用户可能会操纵其计算机上的 Cookie，这意味着会对安全性造成潜在风险或者导致依赖于 Cookie 的应用程序失败。 容易受到CSRF攻击 session当用户打开页面，服务器会生成session,使用session将用户的信息缓存在服务器或数据库中，里面有唯一的sessionID，将sessionID返回给客户端，客户端每次发送请求时，cookie中携带session，服务器通过对比验证用户身份信息，用户离开网站后，session 会被销毁。cookie和session一般不会单独来使用，搭配使用更好。由于cookie内容大小有限而且存在安全问题，所以使用session来存放一些重要信息，cookie存放其他信息。 优点： 安全性更高 缺点： 占用服务器资源 token用户身份验证的方式，最简单的token组成： uid(用户唯一的身份标识)，time(当前时间的时间戳)，sign(签名)，还可以把不变的参数也放进token，避免多次查库。使用token的身份验证，在服务端不需要存储用户的登陆信息，大致流程： 客户端使用账号密码请求登陆 服务端收到请求，验证账号密码 验证成功后，服务端会签发一个token，然后返回给客户端 客户端收到token后，保存在cookie中 客户端每次向服务器请求资源时，携带token 服务端收到请求，去验证token，验证成功，返回数据1.4三次握手四次挥手 1.5手动Promise1.6webpack loader pluging1.7浅拷贝和深拷贝]]></content>
      <categories>
        <category>软件能</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发流程简介]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[开发流程单怼项目的日常在校阶段接触到的项目基本都是单怼的情况比较多，比如程序设计周、老师的一些外包项目以及自己的一些想法的实现。首先说说项目大概会有这么几个阶段： 需求分析 开发阶段、测试阶段 上线 以下的例子均为同一个内容，那就是老师给你布置了一个任务，任务的内容是设计并实现一个校史馆预约系统。 需求分析首先对需求进行分析，由于老师也不是很懂，需要你自己去进行需求分析。首先这个系统肯定需要登录以及权限管理，其次在预约中肯定需要表单的提交以及提交的规则展示，最后需要更高一级的权限对预约进行确认。总结一下有下面几点： 登录、注册、权限 提交预约、通知预约结果 确认(拒绝)预约 查看log 以上几点需求，登录和注册以及是常见并且贯穿两个端(学生端和老师端)的东西，其次提交预约、通知预约结果是学生端的，确认(拒绝)预约和查看log是教师端的。明确需求之后就可以进行开发前的准备了 开发阶段、测试阶段之所以合在一起写是因为在个人开发的时候测试一个模块往往都是自行打log测试，所以在开发的同时就已经完成了测试 开发前的准备需求明确了，这下要明确我们去怎么实现以及怎么去设计系统了。最好的办法就是先制作原型图。 安利一手原型图制作软件：Ant Design、墨刀、蓝湖 然后根据原型图进行技术选型，这里的技术选型就没必要考虑什么了，自己怎么顺手怎么来，不过还是要根据项目的大小以及需求，比如老师会让你必须用小程序之类的。是我的话前端:html css jQuery javascript bootstrap animate.css后端:node express mysql 前端设计选定了这一套技术栈之后就需要对基本架构进行搭建，先说一下前端的基本架构是什么，首先index.html这是前端的入口文件必须要有，其次reset.css这个是对样式进行初始化，最后就是将前面定好的技术栈需要到的包，比如bootstrap、animate下载下来放到lib文件夹。结束了这一切之后文件目录应该是这样的123456789101112├── web│ ├── index.html 入口│ ├── html html文件│ ├── js js文件│ ├── css │ │ ├── reset.css 样式初始化 │ │ ├── style.css 主要样式│ │ └── model.css 适配样式│ │── staic 静态资源部分│ │── lib 需要的模块│ │ ├── bootstrap│ │ └── animate 后端设计后端设计，先设计数据库再进行接口设计。 开发阶段文件目录构建好了之后对逻辑部分就行设计。首先有这么几个功能，提交、通知、确认(拒绝)、登录(登出)、注册、查看log。先对把他们从网页中抽离出来单独编写代码针对这几个功能，然后再还原设计图通过调用这些函数来实现这些交互功能。在写的过程中一边写一边调试，实际上只要搭建好了基础设施建设起来是非常快的。 上线阶段无非就是线上服务器部署、nginx、自动化之类的 多人合作开发当项目变得越来越复杂体量变得越来越大的时候，一个人显得有些独木难支了，这个时候就需要进行多人开发了，多人开发的流程和单人开发其实相似，但是因为项目较大的缘故项目的技术选项可能会有所不同，会选择一些更容易工程化的东西。还是会经历如下几个阶段： 需求分析 开发阶段 测试阶段 上线阶段 需求分析这次我们的例子就用我们的比赛系统，在需求分析阶段和单人开发其实差不多只不过需求更加复杂更加多了，需要合理的给每个人分配。主要的区别应该是在架构阶段和开发阶段。 架构阶段由于需要进行工程化所以在进行技术选型的时候需要做出一些适当的改变，为了迎合大型项目的需求我们选择前端:React Redux redux-thunk next antd axios immutable后端:…. 开发阶段开发阶段需要遵守一定的事先约好的开发规范，最好有一定的代码规范保证自己代码的可读性和可维护性，而管理这个过程可以使用git来进行管理，将代码分成几个分支，主分支用来放最新的上线版本，dev分支放主要开发版本，再建几个历史版本的分支以及几个人各自的开发分支，那么在代码提交合并的时候由leader进行codereview后完成合并，发现问题有leader及时指出改正。 上线阶段也是部署的一些问题不多说]]></content>
      <categories>
        <category>软件能</category>
      </categories>
      <tags>
        <tag>开发心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一些自用工具 SSH工具MobaXtermXshell+File zille浏览器ChromePostman请求模拟器 Google 翻译CaretTab一个精美简单、完全可定制的新式标签页，包括多个时钟、日期、搜索、快速链接等等！ FirefoxGitGithub代码仓库 Gitlab编译器vs codesublime textJetBrains系列IDEA（java）CLion（C/C++）DataGrip(数据库)WebStom(前端)NoteOneNote幕布其他工具Photoshop美图秀秀goland虚拟机Oracle VM VirtualBoxMarkdown一些常用网站https://www.haorooms.com/nav一个前端导航网站https://segmentfault.com/思否https://www.imooc.com/慕课https://www.design-seeds.com/设计种子（找配色的地方）https://stackoverflow.com/stackoverflow（查报错）]]></content>
      <categories>
        <category>软件能</category>
      </categories>
      <tags>
        <tag>工具包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码解析(一)]]></title>
    <url>%2F2019%2F08%2F13%2FReact%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[React组件的实现首先clone一个react的源码，打开入口文件index.js1234567&apos;use strict&apos;;if (process.env.NODE_ENV === &apos;production&apos;) &#123; module.exports = require(&apos;./cjs/react.production.min.js&apos;);&#125; else &#123; module.exports = require(&apos;./cjs/react.development.js&apos;);&#125; 可以发现入口文件仅仅只是做了一个判断是否进入dev模式，因为线上模式的文件是已经压缩过的了不好分析所以我们看生产环境下的development.js。打开development.js文件发现React源码仅有2000多行感觉并不是很多，不过看着这么多看不懂的代码还是很头疼的完全没有一点头绪，所以我们从他暴露出来的部分看看React都有些什么东西。12345678910111213141516171819202122232425262728293031323334353637383940414243444546var React = &#123; Children: &#123; map: mapChildren, forEach: forEachChildren, count: countChildren, toArray: toArray, only: onlyChild &#125;, createRef: createRef, Component: Component, PureComponent: PureComponent, createContext: createContext, forwardRef: forwardRef, lazy: lazy, memo: memo, useCallback: useCallback, useContext: useContext, useEffect: useEffect, useImperativeHandle: useImperativeHandle, useDebugValue: useDebugValue, useLayoutEffect: useLayoutEffect, useMemo: useMemo, useReducer: useReducer, useRef: useRef, useState: useState, Fragment: REACT_FRAGMENT_TYPE, Profiler: REACT_PROFILER_TYPE, StrictMode: REACT_STRICT_MODE_TYPE, Suspense: REACT_SUSPENSE_TYPE, unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE, createElement: createElementWithValidation, cloneElement: cloneElementWithValidation, createFactory: createFactoryWithValidation, isValidElement: isValidElement, version: ReactVersion, unstable_withSuspenseConfig: withSuspenseConfig, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals&#125;; 从他暴露出来的API我们不难发现其实还是很有规律的大概可以根据换行分为这么几个部分。 Children部分。这一部分的API大部分都是对子组件的一些基本操作，比如map、foreach之类的。 Component部分。这一部分大概是讲怎么生成一个组件，以及一个组件到底是什么样子的(绝不可能仅仅只是你定义了一个class而已)。 forwardRef、lazy、memo、createContext。forwardRef 是用来解决 HOC 组件(类似redux中connect的高级组件)传递 ref 的问题的。lazy 是用来实现异步加载功能的。memo 是一个高阶函数，它与 React.PureComponent类似，但是一个函数组件而非一个类。createContext大家可能都不太陌生了，以前都用过context来传值，再新的版本将context改进并投入使用(以前的context性能是真的差)。 user系列。这是React16 的 Hooks。 Fragment、Profiler、StrictMode、Suspense、unstable_SuspenseList。后面的五个都是 React 提供的组件，但他们呢其实都只是占位符，都是一个 Symbol，在 React 实际检测到他们的时候会做一些特殊的处理 createElement、cloneElement、createFactory、isValidElement。从名字就可以看出这是对ReactElement的一些操作。 组件实现首先从组件开始讲起，因为无论是Children部分还是其他的都是基于组件来实现的。新建一个React项目，console一个组件看看控制台是什么样子的。发现这个组件仅仅只是一个对象而已，此时再去对比一下创建组件部分的代码12345678910111213var element = &#123; // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner &#125;; 是不是发现构建一个组件如此简单，我们不妨再往组件里面添加一些东西试试打开控制台我们会发现仅仅只是在props里面增加了同样的东西从这里不难看出这里的DOM组件只是一个个的对象而已，无论多复杂的操作，都只是先进行虚拟DOM的JS计算，把这个组件对象计算好了以后，再一次性的通过Diff算法进行渲染或者更新，而不是每次都要直接操作真实的DOM。调用DOM的开销是很大的。而Virtual DOM的执行完全都在Javascript 引擎中，完全不会有这个开销。在比较原生的jQuery年代，通过JS来操纵DOM元素，而且都是真实的DOM元素，而且我们都知道复杂或频繁的DOM操作通常是性能瓶颈产生的原因，所以React引入了虚拟DOM（Virtual DOM）的概念。知道了组件是什么以后接下来我们去应该了解一下组件是如何被创建的。如何创建一个组件呢？首先当然是创建一个react.element，这里按图索骥可以找到createElement这个方法，前面部分提取了部分保留名称，后面部分对剩余的属性进行了判断并存储在新的props里123456789101112131415161718192021222324252627282930function createElement(type, config, children) &#123; var propName = void 0; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; if (config != null) &#123; if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = &apos;&apos; + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) &#123; if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123; props[propName] = config[propName]; &#125; &#125; &#125; return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125; 可以精简一下，就可以更直观123456789101112function createElement(type, config, children) &#123; var propName = void 0; // Reserved names are extracted var props = &#123;&#125;; var key = null; var ref = null; var self = null; var source = null; return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);&#125; 再顺着这个函数就可以找到ReactElement，找到这个函数就可以发现这才是组件的核心，不难发现这个方法就是上文所提到的创建组件的核心12345678910111213141516171819var ReactElement = function (type, key, ref, self, source, owner, props) &#123; var element = &#123; // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner &#125;; ......(省略部分代码) return element;&#125;; 但是这仅仅只是组件的创建，在React中组件不仅仅只是组件，他分为Component和PureComponent。那么他是如何识别这两种类型的组件并且创建的呢？接下来好好研究一下这个问题。首先，在我们的平常的使用中一个组件自带了很多的方法，那么这些方法是如何挂载到组件上的呢？我们可以从源码中得出答案 123Component.prototype.isReactComponent = &#123;&#125;;Component.prototype.setState = function (partialState, callback) &#123;...&#125;;Component.prototype.forceUpdate = function (callback) &#123;...&#125;; 首先先不管他是如何实现这些方法的，我们从代码中可以得知这些方法都是通过原型链挂载到Component上的。但是组件是分为两个类别的，而我们写代码的时候都是通过一行extends React.component就继承了component的所有方法了。如果要理解其中的秘密我们就只好再去看看PureCompoent的代码了。1234567function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125; 不出意外，还是同样的配方。但是有一些不同的是PureCompoent并没有挂载那几个方法，那么他是如何获得的这些方法的呢？1234567function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;...var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods._assign(pureComponentPrototype, Component.prototype); 我们从代码的前面可以看到他定义了一个ComponentDummy的构造器通过他的原型指向了Component的原型。再后面又实例化了一个ComponentDummy的对象pureComponentPrototype，又通过这个对象的constructor属性指向了PureComponent，因此PureComponent也成为了一个构造器，也就是上面的第二种组件基类。最后一行将两个原型合并，也就是相当于这些方法都有了。 虚拟DOM]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nextjs踩坑日常]]></title>
    <url>%2F2019%2F08%2F05%2Fnextjs%2F</url>
    <content type="text"><![CDATA[写在前面的话接触nextjs的契机可以说是想学着跳出自己写代码的舒适区去学习更多的东西(小声BB如果用React+Redux+React-Router的话项目早就已经写完了)，首先介绍一下我们要做的项目。简单来说就是一个作业平台，只不过这个作业平台还搭载了OJ和后台管理，我主要是负责后台和比赛这两个部分，看起来并不太难，其实难点还是不少的，首先就是nextjs以及服务端渲染我们所有开发人员都没有接触过，其次是MonacoEditor(我并没有做MonacoEditor)，接下来我会以整个项目来简单的说说nextjs的踩坑过程(血泪史). next环境搭建起步其实next的配置其实非常的简单，就像官方文档一样npm install --save next react react-dom就搞定了，再把启动的script加入到packge.json中就ok了。 路由第一步好了以后我开心的好像两百斤的胖子，其实并没有想到这是噩梦的开始，我配置好了首先就是随便写了几个组件试了试传说中不用配置就可以用的路由，发现还是有点东西的，首先是index.js通过next给的Link跳到了其他页面，又从其他页面调回来，这一切看起来并没有任何问题，但仔细一想发现事情并没有那么简单，假如每个组件都可以根据文件路由来跳转的话，那岂不是如果知道了我的文件目录就可以为所欲为了，那还要在每个组件加一个拦截，岂不是太麻烦了，所以就需要禁止文件路由了，在next中并没有react之前那种webpack配置文件所以我们需要自己建一个配置文件next.config.js，并在里面增加1234567module.exports = &#123; distDir: &apos;build&apos;,//自定义构建目录 useFileSystemPublicRoutes: false,//不使用文件路由 generateBuildId: async () =&gt; &#123; return &apos;my-build-id&apos; &#125;//配置构建 ID&#125; 自定义路由第一种方法：新建server当你的路由配置好了之后你会发现又不行了，因为不能用文件路由只能自定义路由了，传统的自定义路由一般就是自己写一个server来自定义，比如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const server = express()server.get(&apos;/home&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/home/home&apos; const queryParams = &apos;home&apos; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/personcenter&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/home/PersonCenter/personCenter&apos; const queryParams = &apos;personcenter&apos; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/assignment&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/assignment/assignment&apos; const queryParams = &apos;assignment&apos; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/assignment/coding&apos;, (req, res) =&gt; &#123; const actualPage = `/assignment/pages/assignmentCoding/pages/codingHome`; const queryParams = &apos;assignmentCoding&apos;; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/assignment/question&apos;, (req, res) =&gt; &#123; const actualPage = `/assignment/pages/assignmentCoding/pages/codingDetail`; const queryParams = &apos;codingDetail&apos;; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/competition&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/competition/competition&apos; const queryParams = &apos;competition&apos; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/competition/Arena&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/competition/competitionArena/competitionArena&apos; const queryParams = &#123; competitionNum: req.query.competitionNum &#125; app.render(req, res, actualPage, queryParams)&#125;);server.get(&apos;/management&apos;, (req, res) =&gt; &#123; const actualPage = &apos;/management/management&apos; const queryParams = &apos;management&apos; app.render(req, res, actualPage, queryParams)&#125;)server.get(&apos;*&apos;, (req, res) =&gt; &#123; return handle(req, res)&#125;) 这样自定义一个server是没有问题的，但是在之前写好的script就要改变一些了，原本启动的命令就应该改成node server.js,打包命令也应该换成NODE_ENV=production node server.js。 第二种方法：更改next.config.js自定义路由配置但是为了简化这些繁琐的步骤，next自己也有一套自定义路由的方法，就是在之前说过的next.config.js中增加自定义路由配置，下面配置的效果和之前写的那个server起到的效果应该是一样的，但是在前者还可以针对一些特殊的路由进行操作，所以我认为前者更好一些(虽然有点麻烦)。12345678exportPathMap: function(defaultPathMap) &#123; return &#123; &apos;/&apos;: &#123; page: &apos;/home/home&apos;, query: &#123; title: &apos;home&apos; &#125; &#125;, &apos;/management&apos;: &#123; page: &apos;/management/management&apos;, query: &#123; title: &apos;management&apos; &#125; &#125;, &apos;/assignment&apos;: &#123; page: &apos;/assignment/assignment&apos;, query: &#123; title: &apos;assignment&apos; &#125; &#125;, &apos;/competition&apos;: &#123; page: &apos;/competition/competition&apos;, query: &#123; title: &apos;competition&apos; &#125; &#125; &#125; &#125; 其他的自定义配置css、less路由搞好了我就开开心心的开始专心安装项目所需要的一些基本的包，像axios啥的装起来用起来可正常了，但是有些东西并非我们想象中的那么简单，比如css、less、Antd，在之前的项目中配置css、less之类的都是在webpack 的配置文件中添加，但是在next中并没有所以我们还得在之前的next.config.js写同样的css和less的配置1234567891011121314151617181920212223242526const withLess = require(&apos;@zeit/next-less&apos;);const withCSS = require(&apos;@zeit/next-css&apos;);module.exports = withCSS(withLess(&#123; webpack(config, options) &#123; config.module.rules.push( &#123; test: /\.(png|jpg|gif|svg|eot|ttf|woff|woff2)$/, use: &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 100000 &#125; &#125; &#125;); config.plugins.push( new MonacoWebpackPlugin() ); return config &#125;, distDir: &apos;build&apos;,//自定义构建目录 useFileSystemPublicRoutes: false,//不使用文件路由 generateBuildId: async () =&gt; &#123; return &apos;my-build-id&apos; &#125;//配置构建 ID&#125;)) 可能这个配置看起来有点沙雕，但是这是经过了一整天的琢磨才想出来的一种能解决问题的写法。 再提一个react的日常问题，AntdAntd出问题不是一天两天了，经常将Antd引入项目后Antd的样式无法生效或者less无法被识别等等。总而言之就是Antd无法被识别了。解决这个问题首先就是要确保你的项目less已经装上了，之后就可以开始愉快的debug了。第一种问题是Antd样式无法生效，其实我也不知道咋回事，但是我得知道怎么解决，只要在你的css或者less的公共样式文件里引入Antd的less或者css文件就好了@import &quot;~antd/dist/antd.less&quot;第二种问题是在第一种问题的基础上发生的@无法被识别，解决这个问题很简单，你可以直接把你的less版本降低到&quot;less&quot;: &quot;^2.7.2&quot;，如果版本不能被降低的话得重新配置less，这个俺现在也没去查。 打个总结其实nextjs的webpack自定义配置的官方文档还是比较清晰的，多查文档多查官方github仓库里的issue和example还是可以解决的。 自定义_app.js先说一下服务端渲染的基本理论以及为什么要用服务端渲染，简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序，再说说他的优势 更利于SEO。不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本（Google除外，据说Googlebot可以运行javaScript）。使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少(如图一)。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。 更利于首屏渲染首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。nextjs帮我们解决了大部分的问题，他解决了渲染的问题而我们则是需要去优化SEO.那么问题来了，如何优化SEO呢？ 首先就是去优化页面的meta部分，meta部分涉及了网页关键词网页描述等，那么在我们写的组件里面可不会有meta，而在项目中也没有一个index.html供我们去写meta，所以我们就用到了_app.js。他的作用就是在生成的所有网页外面再包上一层外衣，这外衣上面就有meta、title等head里面的内容。他还有一个很关键的作用就是注入数据，在SPA中如果没有数据的注入那么网页相当于是空白的，但是在注入数据之后就可以清晰的看出这个网页的作用和内容了，这对于优化SEO是很好的。这就相当于在服务端渲染过后的html已经具备了符合SEO的dom和一些基本的数据了，缺少的只是个性化的一些用户的数据。 nextjs+redux其实nextjs+redux并不困难在官方给的example中代码十分精简，学过redux的同学都应该知道基本的redux在react中的基本配置，就像官方文档给的那样 展开查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;import &#123; composeWithDevTools &#125; from &apos;redux-devtools-extension&apos;const exampleInitialState = &#123; lastUpdate: 0, light: false, count: 0&#125;export const actionTypes = &#123; TICK: &apos;TICK&apos;, INCREMENT: &apos;INCREMENT&apos;, DECREMENT: &apos;DECREMENT&apos;, RESET: &apos;RESET&apos;&#125;// REDUCERSexport const reducer = (state = exampleInitialState, action) =&gt; &#123; switch (action.type) &#123; case actionTypes.TICK: return Object.assign(&#123;&#125;, state, &#123; lastUpdate: action.ts, light: !!action.light &#125;) case actionTypes.INCREMENT: return Object.assign(&#123;&#125;, state, &#123; count: state.count + 1 &#125;) case actionTypes.DECREMENT: return Object.assign(&#123;&#125;, state, &#123; count: state.count - 1 &#125;) case actionTypes.RESET: return Object.assign(&#123;&#125;, state, &#123; count: exampleInitialState.count &#125;) default: return state &#125;&#125;// ACTIONSexport const serverRenderClock = () =&gt; &#123; return &#123; type: actionTypes.TICK, light: false, ts: Date.now() &#125;&#125;export const startClock = () =&gt; &#123; return &#123; type: actionTypes.TICK, light: true, ts: Date.now() &#125;&#125;export const incrementCount = () =&gt; &#123; return &#123; type: actionTypes.INCREMENT &#125;&#125;export const decrementCount = () =&gt; &#123; return &#123; type: actionTypes.DECREMENT &#125;&#125;export const resetCount = () =&gt; &#123; return &#123; type: actionTypes.RESET &#125;&#125;export function initializeStore (initialState = exampleInitialState) &#123; return createStore( reducer, initialState, composeWithDevTools(applyMiddleware()) )&#125; 官方文档其实就已经解决了next with redux 的问题，但是还会出现一个新的问题，就是store无法持续化，假如从A页面通过路由切换到B页面，如果是SPA的话store还可以存在，因为本质上还是同一个网页，但是nextjs不同，他是重新渲染出了一个新的页面以便SEO所以store又重新被初始化了，上一个页面需要持续化到下一个页面的数据就无法获得了，比如什么登录持续化之类的。因此我们就需要解决这个问题，而解决一个问题的工具在官方的example也有但是在文档中并未提及，那就是redux-persist，接下来就说说redux-persist的配置。首先在自己的store文件夹中新增一个高级组件withReduxStore，这个高级组件的代码如下 withReduxStore.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React from &apos;react&apos;import &#123;initializeStore&#125; from &apos;./index&apos;const isServer = typeof window === &apos;undefined&apos;const __NEXT_REDUX_STORE__ = &apos;__NEXT_REDUX_STORE__&apos;function getOrCreateStore(initialState) &#123; if (isServer) &#123; return initializeStore(initialState) &#125; if (!window[__NEXT_REDUX_STORE__]) &#123; window[__NEXT_REDUX_STORE__] = initializeStore(initialState); &#125; //需要放在外面，包含redux的初始function return window[__NEXT_REDUX_STORE__]&#125;export default (App) =&gt; &#123; return class AppWithRedux extends React.Component &#123; static async getInitialProps (appContext) &#123; const reduxStore = getOrCreateStore(); appContext.ctx.reduxStore = reduxStore let appProps = &#123;&#125; if (typeof App.getInitialProps === &apos;function&apos;) &#123; appProps = await App.getInitialProps.call(App, appContext) &#125; return &#123; ...appProps, initialReduxState: reduxStore.getState() &#125; &#125; constructor(props) &#123; super(props) this.reduxStore = getOrCreateStore(props.initialReduxState) &#125; render() &#123; return &lt;App &#123;...this.props&#125; reduxStore=&#123;this.reduxStore&#125; /&gt; &#125; &#125;&#125; 然后再在_app.js中添加并使用，在constructor中继承上一个页面的store _app.js 123456789101112131415161718192021222324252627282930313233343536373839import App, &#123; Container &#125; from &apos;next/app&apos;;import React from &apos;react&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import withReduxStore from &apos;../store/with-redux-store&apos;import Router, &#123;withRouter&#125; from &apos;next/router&apos;import withRedux from &apos;next-redux-wrapper&apos;import Head from &apos;next/head&apos;;import createStore from &apos;../store/index&apos;;import &apos;./index.less&apos;import &apos;../static/fonts/iconfont.css&apos;import &#123; persistStore &#125; from &apos;redux-persist&apos;import &#123; PersistGate &#125; from &apos;redux-persist/integration/react&apos;class MyApp extends App &#123; constructor (props) &#123; super(props) this.persistor = persistStore(props.reduxStore) &#125; render() &#123; const &#123; Component, pageProps, router, reduxStore &#125; = this.props; return ( &lt;Container&gt; &lt;Head&gt; &lt;title&gt;SACC&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width&quot; /&gt; &lt;/Head&gt; &lt;Provider store=&#123;reduxStore&#125;&gt; &lt;PersistGate loading=&#123;&lt;Component &#123;...pageProps&#125; /&gt;&#125; persistor=&#123;this.persistor&#125; &gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/PersistGate&gt; &lt;/Provider&gt; &lt;/Container&gt; ); &#125;&#125;export default withReduxStore(MyApp) 还有一种情况就是需要利用combineReducers整合各个部分的redux，往常我们常用的是redux-immutable中的combineReducers，而对于redux-presite来说并不能识别，所以我们只有使用redux，具体的reducer写法在import { persistReducer } from &#39;redux-persist&#39;后再引入import storage from &#39;redux-persist/lib/storage&#39;，因为从原来上来说持续化store是通过localstorage来完成的，最后就是按照persistConfig来定义每一个部分的reducer，再通过persistReducer(config,reducer)来将配置与reducer结合。 reducer.js 123456789101112131415161718192021222324252627282930313233343536import &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as homeReducer&#125; from &apos;../pages/home/store&apos;;import &#123; reducer as assignmentReducer&#125; from &apos;../pages/assignment/store&apos;;import &#123; reducer as managementReducer&#125; from &apos;../pages/management/store&apos;;import &#123; reducer as competitionReducer&#125; from &apos;../pages/competition/store&apos;;import &#123; persistReducer &#125; from &apos;redux-persist&apos;import storage from &apos;redux-persist/lib/storage&apos;import immutableTransform from &apos;redux-persist-transform-immutable&apos;const homepersistConfig = &#123; key: &apos;home&apos;, storage, whitelist: [&apos;BasicInformationList&apos;,&apos;loginStatus&apos;]&#125;;const competitionpersistConfig = &#123; key: &apos;competition&apos;, storage, whitelist: [&apos;competitionName&apos;]&#125; const managementpersistConfig = &#123; key: &apos;management&apos;, storage, whitelist: [&apos;show&apos;,&apos;showId&apos;,&apos;fromTableList&apos;,&apos;fromTableItem&apos;]&#125;const assignmentpersistConfig = &#123; key: &apos;assignment&apos;, storage, whitelist: [&apos;currentTitle&apos;,&apos;currentColor&apos;,&apos;english&apos;,&apos;currentQuestion&apos;,&apos;questionList&apos;,&apos;totalPage&apos;,&apos;currentPage&apos;,&apos;codingParam&apos;]&#125;const reducer = combineReducers(&#123; home: persistReducer(homepersistConfig, homeReducer), competition: persistReducer(competitionpersistConfig, competitionReducer), management: persistReducer(managementpersistConfig, managementReducer), assignment: persistReducer(assignmentpersistConfig, assignmentReducer)&#125;);export default reducer; 现在redux就配置完了。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2019%2F02%2F28%2FReact%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[render外层嵌套的divrander函数return只能返回一个大的JSX，如果出现两个就需要在外面套一个&lt;div&gt;&lt;/div&gt;但是多出来的一个不必要的div会给我们增加许多的麻烦所以就可以用&lt;React.fragment&gt;&lt;/React.fragment&gt;来取代&lt;div&gt;&lt;/div&gt;。 关于key值的warningWarning: Each child in an array or iterator should have a unique “key” prop.这个Warning代表缺少key值，补充一下key值的是干嘛的： 当我们组件状态更新后，会重新渲染组件，渲染组件的时候会一个个去根据key值的情况去渲染：A. 渲染前的key值存在，则去寻找这个key值对应的组件： &nbsp;&nbsp;a.组件数据不变，则不重新渲染这个组件； &nbsp;&nbsp;b.若组件数据改变，则渲染改变的这一部分数据；B.渲染前的key值不存在，则会销毁这个key值对应的组件：C.出现新的key值，则渲染一个新的key值对应的组件； 父组件与子组件的通信将网页拆分成多个组件之后还可以将大的组件继续拆分，所以就出现了子组件，但是父组件与子组件是如何通信的呢？父组件向子组件传值，这个比较容易理解，例如&lt;TodoItem handDelete={this.handDelete.bind(this)} key={index} index={index} content={item}/&gt;中的content就是向子组件传递了一个item值，在子组件接手数据的时候则是this.props.content等于父组件中的item值。子组件如何与父组件通信总的来说就是通过函数传递，父组件那边写好了处理子组件数据的函数并传给子组件，子组件调用函数并传入数据，父组件就可以接收数据并存储。 React里面写函数有特定的规则React里面写函数有特定的规则，例如onClick={this.handleBtnClick.bind(this)}与普通JavaScript不同的是大小写和花括号的区别，调用css的区别也差不多用的是className={style}而不是class=“style”。总的来说再我看来，大概就是有这么几种情况，当代码块中间有-之类的，比如font-size:48px就需要改写成驼峰写法fontSize:48px，还有就是与语法冲突了比如css中的class和JavaScript中的class重名了所以才需要用className来表示类名。 JSX注释123456在JSx中注释与在JavaScript中略有不同，之前说过在JSX想写js的话需要加一个&#123; &#125;写注释的时候同理&#123;/*这是注释*/&#125;单行注释比较麻烦&#123;//这是注释&#125; 输入不转译&lt;li&gt;dangerrouslySetInnerHTML={{__html: item}}&lt;/li&gt; 利用lable聚焦123&lt;lable&gt;输入聚焦&lt;lable htmlFor=&quot;a&quot;&gt;输入内容&lt;/lable&gt;&lt;input id=&quot;a&quot;&gt; 关于Registerserviceworkerimport Registerserviceworker from ‘Registerserviceworker’；PWA progressive web application,它在有https协议的服务器上缓存可以离线运行。 科普PWAPWA全称Progressive Web App，直译是渐进式WEB应用，是 Google 在 2015 年提出，2016年6月才推广的项目。是结合了一系列现代Web技术的组合。在网页应用中实现和原生应用相近的用户体验。所谓的P（Progressive）这里有两层含义，一方面是渐进增强，让WEB APP的体验和功能能够用渐进增强的方式来更接近原生APP的体验及功能。另一方面是指下一代WEB技术。PWA并非描写叙述一个技术。而是一些技术的合集。 propTypes与defaultPropspropTypes顾名思义prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型。eg：1234567891011121314151617yourComponent.propTypes = &#123; 属性1：属性1的变量类型， 属性2：属性2的变量类型 //...&#125;XX.propTypes = &#123; optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型 number:PropTypes.oneOfType( [PropTypes.string,PropTypes.number] )//规定多个检测通过的数据类型&#125; defaultPropsReact组件的默认状态（defaultProps），给你的数据设定默认数据。eg：123456789101112131415161718192021222324class XX extends React.Component &#123; constructor(props)&#123; super(props); this.state=&#123; name:props.name &#125;; &#125;&#125;XX.defaultProps=&#123; name:&apos;default name&apos;&#125;;orconst XXX=(props)=&gt;&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; );&#125;XXX.defaultProps=&#123; name:&apos;default name&apos;&#125;; state props renderprops设置 props 的方式1）可以在组件挂载时设置props：123456var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);React.render(&lt;HelloWorld name=&quot;Sam&quot; /&gt;, document.body); 2）也可以通过调用组件实例的setProps()方法来设置props（在ES6中将被禁用，这个方法不支持ES6类组件React.Component扩展。）1234567var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);var instance = React.render(&lt;HelloWorld/&gt;, document.body);instance.setProps(&#123;name: &apos;Tim&apos;&#125;); prop 支持的数据类型我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop：&lt;App id=&quot;sample&quot; borderWidth={2} onClick={onButtonClick}/&gt;在上面的例子中，创建了名为 App 的组件实例，使用了名字分别为id、borderWidth、onClick和style的 prop，看起来，React组件的 prop 很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌的JavaScript，也依然是字符串形式表示代码。React组件的 prop 所能支持的类型则丰富得多，可以是任何一种JavaScript语言支持的数据类型。比如在上面的App中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当 prop 的类型不是字符串类型时，在JSX中必须用花括号{}把 prop 值包住，所以style的值有两层花括号，外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。当外部世界要传递一些数据给React组件，一个最直接的方式就是通过 prop；同样，React组件要反馈数据给外部世界，也可以用 prop，因为 prop 的类型不限于纯数据，也可以是函数，函数类型的 prop 等于让父组件交给了子组件一个回调函数，子组件在恰当的实际调用函数类型的 prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。不要修改props这样是反模式，因为 React 不能帮你检查属性类型（propTypes）。这样即使你的属性类型有错误也不能得到清晰的错误提示。Props 应该被当作禁止修改的。修改 props 对象可能会导致预料之外的结果，所以最好不要去修改 props 对象。关于super(props)如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过 super 调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过 this.props 访问到父组件传递过来的 props 值。 关于 statethis.state 与 this.setState在代码中，通过 this.state 可以读取到组件的当前 state。值得注意的是，我们改变组件 state 必须要使用 this.setState 函数，而不能直接去修改 this.state 。直接修改 this.state 的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了 state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应 this.state 值的变化；而 this.setState() 函数所做的事情，首先是改变 this.state 的值，然后驱动组件经历更新过程，这样才有机会让 this.state 里新的值出现在界面上。构造函数 constructor初始化 state，因为组件生命周期中任何函数都可能要访问 state，那么整个生命周期中第一个被调用的构造函数自然是初始化 state 最理想的地方；绑定成员函数的 this 环境；在ES6语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的。而在构造函数中，this 就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前实例。 render通常一个组件要发挥作用，总是要渲染一些东西，render 函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。（render函数并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。）需要注意，render 函数应该是一个纯函数，完全根据 this.state 和this.props 来决定返回的结果，而且不要产生任何副作用。在 render 函数中去调用this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。父组件的render运行时子组件的render自动被重新运行一次 虚拟DOM1、state 数据2、JSX 模板3、生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）[&#39;idv&#39;,{id:&#39;abc&#39;},[&#39;span&#39;,{},&#39;hello world&#39;]]4、用虚拟结构的DOM生成真实的DOM&lt;div id=&#39;a&#39;&gt;&lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;5、state发生变化6、生成新的虚拟DOM7、比较原始虚拟DOM和新的虚拟DOM的区别，找到区别的内容 Diff，当第一层不同的时候删除以下所有DOM节点，用新的替换， 同层比较，算法简单，与key值做关联。index不作为key值的理由：删除一个节点所有index发生变化与旧的虚拟DOM不相同无法建立关联损耗性能 8、直接操作DOM替换其中不同的地方优点：1、性能提升了2、它使得跨端应用得以实现，React Native。3、JSX -&gt; Js对象(React.createElement) -&gt; 真实的DOM（不用去繁琐的使用React.createElement(&#39;div&#39;,{},&#39;item&#39;)）//React.createElement(&#39;div&#39;,{},&#39;item&#39;)是更为底层的语法 生命周期函数生命周期函数指在某一个时刻组件会自动调用执行的函数，render就是一个生命周期函数。组件经历过的几个过程：初始化定义state接收props挂载 componentWillMount（组件即将被挂载到页面的时候执行） render componentDidMount（组件被挂载之后执行） 组件更新 当数据（props、state）发生变化时执行生命周期函数，shouldComponentUpdata(组件即将被变更)产生布尔返回值，true是需要改变组件，false不需要更新。 componentWillUpdata（组件被更新之前shouldComponentUpdata返回true执行）。 render重新渲染。 componentDidUpdata（组件更新完成之后执行）。 componentWillReceiveProps（没有props的情况下不会被执行，顶层组件没有接收所以不会调用。当一个组件从父组接收参数，只要父组件的render函数被重新执行了，子组件的这个函数就会被执行） 去除挂载 componentWillUnmount（当这个组件即将被从页面种剔除的时候执行的函数） 所有生命周期函数可以不存在，render函数必须存在，因为之前继承了component里面就已经有了 DOM节点操作与插件结合我们可以在任何网页应用中使用 React。不仅可以把 React 添加到其他应用里，而且只要稍作改动，我们也可以把其他应用添加到 React 项目里。将 React 与 jQuery 结合使用。当然，类似的思路同样可以应用与其他场景。对于 React 之外的 DOM 节点操作，React 是不会去处理的，因为 React 内部有自己的渲染逻辑。当相同的 DOM 节点被外部的代码改变时，React 就会很迷茫，并不知道发生了什么。在这里，我们给 DOM 的根节点元素加了一个 ref。在 componentDidMount 中，我们会调用这个 ref，并把它传给 jQuery 插件。123456789101112131415161718class SomePlugin extends React.Component &#123; componentDidMount() &#123; this.$el = this.el;//获取到DOM节点，可以对DOM进行操作 this.$el.&#123; //对DOM进行操作 Do something innerHTML append &#125; &#125; componentWillUnmount() &#123; this.$el.somePlugin(&apos;destroy&apos;);//卸载事件监听器 &#125; render() &#123; return &lt;div ref=&#123;el =&gt; this.el = el&#125; /&gt;; &#125;&#125; 为了防止 React 在 DOM 加载后修改节点，我们先要在 render() 中返回一个空的 &lt;div /&gt;。这个空的&lt;div /&gt;既没有属性也没有子元素，这样一来，React 就不会更新它了。那么，我们封装的 jQuery 插件就可以随意地更新这个节点。其实这样做不只使用与jQuery ，同样适用于原生的JavaScript的DOM操作。在实战经过一系列实践之后发现事情远远没有这么简单，如果将DOM操作放到componentDidMount()的确能在第一次渲染的时候有效的进行DOM操作，但是再对这个组件进行操作的时候，比如一个下拉框，如果我用this.state.isShow:true来控制显示与否，那么更改了这个组件的状态就不会再触发DOM操作。现在仍然没有找到什么好的方法来解决，在React中自己有一套方案，我记得好像是dangerrouslySetInnerHTML={}，但是从名字就能看出来这并不是什么好东西，因为这个方法很容易受到XSS攻击。在上述还触发DOM操作的钩子中仍然存对生命周期函数不太掌握，还要好好看看，下面再补上。 生命周期函数 条件渲染组件在Reactd的实际操作中有许多需要条件渲染的组件，比如在登陆窗口，已登录和未登录的肯定需要渲染不同的组件，这就涉及到了一个条件渲染的问题，在jsx中使用条件语句来生成特定的组件，首先需要介绍的应该是map，当需要取出一个数组中的所有item来循环生成一个list，这时就需要一个map来拯救你，this.state.data((item)=&gt;&lt;App&gt;{item.text}&lt;/App&gt;)，这样就省去了很多不必要的麻烦。然后我要介绍的是三元运算符生成组件，就好像前面举的例子，在登陆的时候，需要一个flag来判断用户是否已经登陆然后生成对应的组件，{this.state.flag?&lt;In/&gt;:&lt;Out/&gt;},这样就很舒服了。想到了条件，总是忘不了if...else...，那么在jsx中如何运用这些常用的条件判断来生成组件呢1234567891011121314class SomePlugin extends React.Component &#123; //省略部分代码 render() &#123; let item; if(this.state.isShow)&#123; item = this.state.data((item)=&gt;&lt;A&gt;&#123;item.text&#125;&lt;/A&gt;); &#125;else&#123; item = this.state.data((item)=&gt;&lt;B&gt;&#123;item.text&#125;&lt;/B&gt;); &#125; return (&lt;div&gt; &#123;item&#125; &lt;/div&gt;); &#125;&#125; 在render()函数中用一个变量代替HTML代码，再用平时熟悉的JavaScript写条件判断就容易很多了，最后在return中需要渲染的地方加上这一个变量就OK了，真的很舒服啊~]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀奇古怪的JavaScript]]></title>
    <url>%2F2019%2F02%2F26%2F%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84JavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript 中 undefined 和 not defined 的区别JavaScript 未声明变量直接使用会抛出异常：var name is not defined，如果没有处理异常，代码就停止运行了。但是，使用typeof undeclared_variable并不会产生异常，会直接返回 undefined。 if (function f(){})与eval()12345var x = 1;if (function y()&#123;&#125;) &#123; x += typeof y;&#125;console.log(x);// 1undefined JavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。下面我们可以把代码改造下，变成其等效代码。123456var x = 1;if (1) &#123; eval(function y()&#123;&#125;); x += typeof y;&#125;console.log(x);// 1undefined eval():该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。如果去除eval()的话就是返回1function 123456var x = 1;if (1) &#123; function y()&#123;&#125;; x += typeof y;&#125;console.log(x); // 1function]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据可视化]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近接手了一个项目，用到了数据可视化，所以今天想给大家简单的说说数据可视化。 首先我们说说为什么要做数据可视化？快视觉是人类获取外界信息最高速，最主要也是最重要渠道。超过50%的人脑功能用于视觉感知，而大脑接收到的信息 90％ 来自视觉，人类利用视觉获取和处理的信息量，远远超出其他途径。人类大脑处理图像的速度比文本快 6 万倍。所谓的“可视化”，就是利用人类视觉化的思考能力，对数据进行可视表达以增强认知的技术。请问上图有多少个V?短时间内，应该很难找到答案吧。我们把上面的图形改造一下，再试一次？现在找到答案就轻而易举了。 有效数据可视化的有效在于，它能够把不易理解的关联维度直观形象地表达出来。最常见的就是地理空间信息，通过地图可以快速有效地得到数据集的宏观理解，所以有这样一句话，“面向公众用户，传播与发布复杂信息最有效途径就是数据可视化”。通过简单的一张图表直观有效的了解了全国各地的空气质量分布 美数据可视化是创造性的设计美学、缜密的数据算法和严谨的工程技术结合的产物，用形象、有趣的形式呈现沉闷繁杂的数据。好的数据可视化作品不仅能挖掘出数据中蕴含的洞察，还能体现出数据之美。数据可视化的表现和创作过程本身就是一门艺术。例如在阿里2017双11购物节 区域经济媒体大屏“中国区域经济闪电图”媒体触控大屏是2017年双11晚会现场的核心焦点之一，大屏上全国上亿买家的订单沿着真实道路涌向卖家，效果震撼。 触控大屏支持用户自助下钻查询数据，极大地增强数据的可读性。当天累计有超过500家中外媒体以此作为现场直播的数据讲解平台，实现了新旧媒体完美融合。 Web 上的数据可视化技术底层技术规范在介绍 Web 上的数据可视化技术前，我们先了解下 Web 图形的底层技术规范： SVG：可缩放矢量图形（Scalable Vector Graphics），是基于可扩展标记语言（标准通用标记语言的子集）的用于描述二维矢量图形的一种图形格式。Canvas 2D：Canvas 通过 JavaScript 来绘制 2D 图形，通过逐像素来进行渲染。Canvas 3D WebGL：WebGL（Web Graphic Library）是一个 JavaScript API，用于在任何兼容的 Web 浏览器中渲染 3D 图形。WebGL 程序由用 JavaScript 编写的控制代码和用 OpenGL 着色语言（GLSL）编写的着色器代码构成，这种语言类似于 C 或 C++，可在 GPU 上执行。 比较流行的基础绘图库，基于 SVG 的有 snap.svg、rapheal.js 等，基于 Canvas 2D 的有 zrender、g 等，基于 WebGL 的有 three.js、SceneJS、PhiloGL 等，这些基础绘图库可以让上层封装更简单容易。 一些相对成熟的解决方案EChartsECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 AntVAntV是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、不限可能的数据可视化最佳实践。 D3相对于echart, highchart等其他图表库算是一个比较底层的可视化工具，简单来讲他不提供任何一种现成的图表，所有的图表都是我们在它的库里挑选合适的方法构建而成。 怎么设计数据可视化选择解决方案在有了成熟的解决方案和相应的库以后代码的问题似乎不是很大，但是可视化的自由程度取决于你对库的选择，像Antv所展示的相关案例就比较简洁大方，而你想要做一些花里胡哨的东西的时候就无从下手只能换库，或者自己手写就很费劲，所以在设计的时候一定要确定自己的这一个Dashboard需要做到什么的一个效果，或简洁，或花哨，从而去把握对解决方案的选择。 布局设计在确定了使用哪一个库之后需要对自己展示的Dashboard有一个大概的设计，先不说配色但是起码的布局得先有大概的一个想法。 指标在布局设计的同时需要关注指标问题，在一个Dashboard中需要展示的东西很多，但是这些东西也是有主次之分的，大概可以先分为主要的两类：主要指标、次要指标。主要次要相对于整个Dashboard而言的，将主要指标放在相对显眼的位置，主要指标很引出一些次要指标，这些次要指标随着主要指标的变化而变化。首先要区分占面积的大小，其次要区分配色！上面这个图是我最近项目做的一个图，因为数据还未完善所以不太好看，在这个图中的主要指标就是地图，总趋势分析和专利对比分析等等都是次要指标，次要指标围绕着主要指标来展示，让人感觉层次清晰。 配色直男癌的配色，你还要我怎样 数据处理做Dashboard最重要的就是数据，而从数据库获取的数据肯定是无法直接投入到代码中去使用的，更何况还有许多奇葩的需求，所以数据的处理更为重要，虽然说后端已经帮你处理了大部分数据，但是因为我们是选择了别人的解决方案所以数据也应该相应的改变，大部分解决方案有了自己的transform方法，可以根据实际情况对数据进行二次处理，说实话我并不太喜欢用这个方法，我喜欢自己去按自己喜欢的方式去处理数据，这样自己理解起来更为方便，换库的时候也不至于令人莫不着头脑。 总结一下我们日常工作总是谈论“用数据说话”，我们肯定不希望我们的目标受众听完就忘了，数据可视化的一个很重要能力就是能够“让受众记住”。无论是美观还是其他什么的，最重要的就是让人能够记住能够理解，这就是去做数据可视化的意义。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计大赛心得]]></title>
    <url>%2F2018%2F11%2F27%2Fdevelopment-website%2F</url>
    <content type="text"><![CDATA[网页设计大赛心得说在前面的话 本次比赛从十月十一号正式在Gitlab上搭建，做的题材就是我们院科协的1.0版本，临时参考了各种酷炫网站的各种特效并打算将其组合起来，但是发现实际效果好像不太行，所以决定走简约风格，而这个呢就是参考某一个网站具体网址我也忘了。啰嗦了这么多就开始进入正题吧。 技术选型 首先说说技术选型，其实我也考虑了vue+webpack+vuex这一套，但是因为这个比赛比较简单也不需要做SPA从短期来看用这一套就感觉不太好，所以呢我就考虑了jQuery+Bootstrap来一揽子搞定它，后来不知怎么的好像一开始布局的时候哪里抽了不知道，忘记使用bootstrap了，所以就决定玩一把大的，自己处理布局问题不再使用栅格系统，随之而来的问题就是移动端什么的都得自己解决了，这很是令人头秃，但是却也让我们放开了手脚，直接开始浪！所以我们唯一使用的库就只有jQuery了！ 开发中的一些问题 这次因为比赛原因仓库项目并不能公开，所以我们把它放在了Gitlab上，首先说说整个结构 一目了然了吧，我们这个项目是十分简单的（虽然后期不利于维护，但是那已经不是我们的锅了，只能给接锅的人说抱歉了），images里面不仅存了图片还有一些其他的多媒体资源，lib放的是一些外部的库。 其实吧，我jio得整个项目都简单的一批，虽然简单但是还是听我们叨叨（吐槽）一会儿吧，首先就是布局上踩了无数的坑以及在其他终端的适配出现了许多魔性的bug，比如什么fixed以后会被背景盖住，懒加载没有加载出来时高度消失了之类的玄学问题，让我对CSS又有了新的认识，我再也不敢小觑它了，太可怕了。当整个页面布局开始复杂的时候，因为没有用bootstrap所以想要调整某一块的布局时不得不往上再调整几个父容器，不由的感叹我们的头真铁啊！在js方面的话，因为是合作开发所以有些地方就比较乱，这也是没有套用框架的一个不好的地方吧，我们不能实现模块化组件化开发，两个人同时写js势必会相互影响，所以后期基本都是在互相调bug，以及互相看不懂代码等等各种奇葩问题，技术能力没有长进多少，甩锅能力堪称一流了。最后还想吐槽一下Team部分的介绍部分，感觉自己都被掏空了，是我太菜还是我菜我已经分不清了，在判断页面是否显示介绍文字这一块掉了我不少头发，因为在HTML中每一个item嵌套了太多个盒子，在查询判断的时候不考虑时间的话之间用循环慢慢找就好，但是需要考虑到用户体验提高速度就不得不先获取点击item的id再向上查找对应的介绍部分，在所借鉴的例子中采用的是每一个item对应一个节点，而我是只有一个节点，根据不同的item的id查询到相应的介绍文字并将节点里的文字图片替换，感觉多此一举了。反而一开始认为很难的canvas动画部分被很轻易的就搞定了，真的是太XX了。最后小声bb几句（真正的懒加载，监听视窗到达相应高度出现内容，这是传统的懒加载，实现原理就是改变src来解决的，实际的DOM是已经存在的，而我们加的这个戏就很棒了，搞一个真正的懒加载？？？我们直接移除节点，到了指定位置再加载节点，天呐，现在回想起来我都在想我们是不是疯了，lazyload不好用么，为什么要这么折腾自己呢） 写代码的时候大概就是那么多问题了，我甚至觉得写了这么一个项目到底值不值得我写一篇心得来总结它，因为它太简单了，但是因为我们的各种加戏变得不简单了。 开发周期 接下来是时间的安排，时间上还是比较充裕的（一开始），后来发现剩下两周居然是实训周，所以后期就比较赶，大部分功能内容都是在那一段时间赶出来的，想想我们，刚刚磨完锤子，又要去调布局做动画，我哭了，你呢？！ 最后再说几句 好了，这个项目大概就是这样了，上一年大一的时候自己心心念念想做的东西到现在真正的做出来了反而没有了当初那一份说不出来的感觉了最后上地址http://njupt-sacc.com/ 之后会再写一些遇到的问题以及解决方案]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>网页设计大赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F10%2F29%2FES6%2F</url>
    <content type="text"><![CDATA[ES6 各种新语法 入门了解 石川blue讲解 视频地址 b站：深入解读ES6系列 看视频整理要点笔记: hello-es6 1.ES6怎么来的 2.ES6兼容性 3.变量 let 和 常量 const 4.函数-箭头函数 5.函数-参数 6.解构赋值 7.数组 8.字符串 9.面向对象-基础 10.面向对象应用 11.json 12.Promise 13.generator-认识生成器函数 14.generator-yield是啥 15.generator-实例 16.ES7 预览 1.ES6怎么来的 ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES 历史版本 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布 2.ES6兼容性 ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换 在线转换 或者提前编译 Babel 中文网 Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.变量 let 和 常量 const var 的问题 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { } let 和 const 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改 块级作用域举例 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload= function () &#123; /* var aBtn = document.getElementsByTagName('input') for (var i=0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;*/ var aBtn = document.getElementsByTagName('input') for (let i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125; /* var aBtn = document.getElementsByTagName('input') for (var i = 0; i &lt; aBtn.length; i++) &#123; // 封装到函数里，限制作用域 (function (i) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;)(i) &#125;*/ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="按钮1"&gt; &lt;input type="button" value="按钮2"&gt; &lt;input type="button" value="按钮3"&gt;&lt;/body&gt;&lt;/html&gt; 4.函数-箭头函数 箭头函数，就是函数的简写 如果只有一个参数，() 可以省 如果只有一个return，{}可以省 12345678// 普通函数function name() &#123;&#125;// 箭头函数，去掉 function， 加上 =&gt;() =&gt; &#123;&#125; 12345678910111213141516171819let show1 = function () &#123; console.log('abc')&#125;let show2 = () =&gt; &#123; console.log('abc')&#125;show1() // 调用函数show2()let show4 = function (a) &#123; return a*2&#125;let show5 = a =&gt; a * 2 //简洁，类似python lambda 函数console.log(show4(10))console.log(show5(10)) 5.函数-参数 参数扩展／展开 ...args 收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样 默认参数 12345678910111213141516function show(a, b, ...args) &#123; console.log(a) console.log(b) console.log(args)&#125;console.log(show(1, 2, 3, 4, 5))let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]let arr3 = [...arr1, ...arr2]console.log(arr3)function show2(a, b=5, c=8) &#123; console.log(a, b, c)&#125;show2(88, 12) 6.解构赋值12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c)let &#123;x, y, z&#125; = &#123;x: 1, y: 2, z: 3&#125;console.log(x, y, z)let [json, arr, num, str] = [&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, 'str']console.log(json, arr, num, str) 解构赋值 左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里 7.数组 新增4个方法 map 映射 一个对一个 12345678910111213141516let arr = [12, 5, 8]let result = arr.map(function (item) &#123; return item*2&#125;)let result2 = arr.map(item=&gt;item*2) // 简写console.log(result)console.log(result2)let score = [18, 86, 88, 24]let result3 = score.map(item =&gt; item &gt;= 60 ? '及格' : '不及格')console.log(result3)// 结果[ 24, 10, 16 ][ 24, 10, 16 ][ '不及格', '及格', '及格', '不及格' ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 1234567891011121314151617var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; //tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item&#125;)console.log(result)var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; if (index != arr.length - 1) &#123; // 不是最后一次 return tmp + item &#125; else &#123; return (tmp + item)/arr.length &#125;&#125;)console.log(result) // 平均值 filter 过滤器 保留为true的 123456789101112var arr = [12, 4, 8, 9]var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)console.log(result)var result = arr.filter(item =&gt; item % 3 === 0)console.log(result)var arr = [ &#123; title: '苹果', price: 10 &#125;, &#123; title: '西瓜', price: 20 &#125;,]var result = arr.filter(json =&gt; json.price &gt;= 20)console.log(result) forEach 循环迭代 123var arr = [12, 4, 8, 9]var result = arr.forEach(item =&gt; console.log(item))var result = arr.forEach((item, index)=&gt;console.log(item, index)) 8.字符串 多了两个新方法 startsWith endsWith 1234var url = 'http://qq.com'console.log(url.startsWith('http'))console.log(url.endsWith('com'))// 都是 true 字符串模版 使用反引号，${变量} 可以折行 1234567891011121314let a = 12let str1 = `asdf$&#123;a&#125;`console.log(str1)let title = '标题'let content = '内容'let str = `&lt;div&gt;&lt;h1&gt;$&#123;title&#125;&lt;/h1&gt;&lt;p&gt;$&#123;content&#125;&lt;/p&gt;`console.log(str)&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;内容&lt;/p&gt; 9.面向对象-基础 原来写法 类和构造函数一样 属性和方法分开写的 123456789101112131415161718192021222324252627282930// 老版本function User(name, pass) &#123; this.name = name this.pass = pass&#125;User.prototype.showName = function () &#123; console.log(this.name)&#125;User.prototype.showPass = function () &#123; console.log(this.pass)&#125;var u1 = new User('able', '1233')u1.showName()u1.showPass()// 老版本继承function VipUser(name, pass, level) &#123; User.call(this, name, pass) this.level = level&#125;VipUser.prototype = new User()VipUser.prototype.constructor = VipUserVipUser.prototype.showLevel = function () &#123; console.log(this.level)&#125;var v1 = new VipUser('blue', '1234', 3)v1.showName()v1.showLevel() 新版面向对象 有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类 12345678910111213141516171819202122232425262728293031class User &#123; constructor(name, pass) &#123; this.name = name this.pass = pass &#125; showName() &#123; console.log(this.name) &#125; showPass() &#123; console.log(this.pass) &#125;&#125;var u1 = new User('able2', '111')u1.showName()u1.showPass()// 新版本继承class VipUser extends User &#123; constructor(name, pass, level) &#123; super(name, pass) this.level = level &#125; showLevel()&#123; console.log(this.level) &#125;&#125;v1 = new VipUser('blue', '123', 3)v1.showLevel() 10.面向对象应用 React 用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js 11.json JSON 格式 JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来 JSON 对象 JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 123456789101112var json = &#123;a: 12, b: 5&#125;var str = 'hi,' + JSON.stringify(json)var url = 'http://www.xx.com/' + encodeURIComponent(JSON.stringify(json))console.log(str)console.log(url)var str = '&#123;"a": 12, "b": 4, "c": "abc"&#125;'var json = JSON.parse(str)console.log(json)hi,&#123;"a":12,"b":5&#125;http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D&#123; a: 12, b: 4, c: 'abc' &#125; 对象（object） 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for…in循环用来遍历一个对象的全部属性 对象 简写 key-value 一样时可以简写 里面函数可以简写, 去掉 123456789var a = 12, b = 5console.log(&#123;a:a, b:b&#125;)console.log(&#123;a, b&#125;)console.log(&#123;a, b, c:"c"&#125;)console.log(&#123; a, b, show()&#123; console.log('a') &#125;&#125;)&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5, c: 'c' &#125;&#123; a: 12, b: 5, show: [Function: show] &#125; 12.Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise 对象 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 Promise 也是一个构造函数 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数 12345function f1(resolve, reject) &#123; // 异步代码...&#125;var p1 = new Promise(f1);p1.then(f2); // f1的异步操作执行完成，就会执行f2。 Promise 使得异步流程可以写成同步流程 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 13.generator-认识生成器函数 generator 生成器函数 普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停 123456789101112131415function show() &#123; console.log('a') console.log('b')&#125;show() // 普通函数function *show2() &#123; console.log('1') yield console.log('2')&#125;let genObj = show2()genObj.next() // 1genObj.next() // 2genObj.next() // 最后了，没有结果 14.generator-yield是啥 yield 既可传参，又可以返回 第一个next()传参无效，只用来启动 如果函数前漏掉 * 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用 1234567891011121314151617181920212223242526function * show() &#123; console.log('1') var a = yield console.log('2') console.log(a)&#125;// yield 传参var gen = show()gen.next() // 1gen.next() // 2 和 undefined 因为没有传参，yield没有返回值var gen = show()gen.next(10) // 1 第一次执行到yield，但没有执行赋值gen.next(20) // 2 和 20function* show2() &#123; console.log('1') yield 10 console.log('2')&#125;// yield 返回var gen = show2()var res1 = gen.next()console.log(res1) // &#123; value: 10, done: false &#125;var res2 = gen.next()console.log(res2)// &#123; value: undefined, done: true &#125; 最后的value需要return返回 15.generator-实例 Promise 适合一次读一组 generator 适合逻辑性的 12345678910// 带逻辑-generatorrunner(function * () &#123; let userData = yield $.ajax(&#123;url: 'getUserData'&#125;) if (userData.type == 'VIP') &#123; let items = yield $.ajax(&#123;url: 'getVIPItems'&#125;) &#125; else &#123; let items = yield $.ajax(&#123;url: 'getItems'&#125;) &#125;&#125;) 12345// yield 实例，用同步方式写异步server.use(function * () &#123; let data = yield db.query(`select * from user_table`) this.body = data&#125;) 16.ES7 预览 数组 arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for … in 遍历数组 下标 key for … of 遍历数组 值 value, 不能用于json 123456789101112131415161718192021let arr = ['a', 'b', 'c']console.log(arr.includes(1))for (let i in arr) &#123; console.log(i) // 循环的时下标 key&#125;for (let i of arr) &#123; console.log(i) // 循环的是值 value&#125;for (let i of arr.keys()) &#123; console.log('&gt;'+i)&#125;for (let [key, value] of arr.entries()) &#123; console.log('&gt;' + key + value)&#125;let json = &#123; a: 12, b: 5, c: 7 &#125;for (let i in json) &#123; console.log(i)&#125; 字符串 padStart()/padEnd() 指定宽度，不够就补空格或指定字符 1234console.log('=' + 'abcd'.padStart(6, '0') + '=')console.log('=' + 'abcd'.padEnd(6, '0') + '=')=00abcd==abcd00= 容忍度 [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以 async await 和 generator yield 类似 generator 不可以写成箭头函数， async 可以 12345async function show() &#123; console.log(1) await console.log(2)&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antv]]></title>
    <url>%2F2018%2F10%2F19%2FAntv%2F</url>
    <content type="text"><![CDATA[Antv踩的一些坑因为项目需要做一些数据可视化的东西，一开始考察了几个库，比如：echart、D3、antv，因为后面可能需要做一些类似地图的图表而echart这个库做不了，还改了一次库，D3的话上手难度比较高。具体的一些设置我就不说了，官方文档写的相当详细了。创建一个图表可以说是相当的简单，你只需要123456var chart=new G2.chart(&#123; container: &apos;id&apos;,&#125;);chart.source(data);chart.interval().postion(&apos;x*y&apos;).size(5);chart.render(); 可以看到只需要指定一个id和一个数据来源就可以建立一张简单的表了，这个有一个坑就是数据的问题，x*y对应data中的字段，eg:1234567891011var data=[ &#123;time:&apos;2008&apos;,num:30,percentage:0&#125;, &#123;time:&apos;2009&apos;,num:40,percentage:0.33&#125;, &#123;time:&apos;2010&apos;,num:44,percentage:0.1&#125;, &#123;time:&apos;2011&apos;,num:38,percentage:-0.16&#125;, &#123;time:&apos;2012&apos;,num:26,percentage:-0.32&#125;, &#123;time:&apos;2013&apos;,num:33,percentage:0.27&#125;, &#123;time:&apos;2014&apos;,num:44,percentage:0.33&#125;, &#123;time:&apos;2015&apos;,num:37,percentage:-0.16&#125;, &#123;time:&apos;2016&apos;,num:47,percentage:0.27&#125;, &#123;time:&apos;2017&apos;,num:55,percentage:0.15&#125;]; 如果设置postion(‘time*num’)就对应设置成time字段的数据为x轴，num数据为y轴。这里又引出了一个新的坑，比如如果你的字段是英文的但是你在x轴显示的时候你想展示成英文的你就需要为你的字段设置一个新的别名来改变原有的英文字段，eg:12345678chart.scale(&#123; &apos;name&apos;: &#123; alias: &apos;IPCs&apos; // 设置属性的别名 &#125;, &apos;value&apos;: &#123; alias: &apos;数量&apos; &#125; &#125;); 这样就可以将name的别名改为IPCs在网页显示的时候显示的也是IPCs，下面的value同理。 之后会讲一些回调函数等着再更新未完待续！]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 搭博客踩坑大全]]></title>
    <url>%2F2018%2F10%2F19%2Fhexo-%E6%90%AD%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Git+hexo 搭博客 作为一个老学长帮新生搭博客，在这过程中遇到了许多坑，什么大小写问题全角标点不注意空格看不到之类的已经数不胜数了，下面有几点要注意！！！！！！ 仔细看好大小写注意全角和半角的切换配置里冒号后面都有空格安装Git bash，安装Nodejs，注册Github安装Git bash和Nodejs直接在官网安装就好了，然后到github上注册账号 安装hexo安装hexo的话，打开cmd输入npm i -g hexo,如果加载速度过慢或者不动的话建议换一个网络试试 生成ssh key生成ssh key打开你的Git bash，输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot;,接下来连续三个回车出现一个个人ssh key，然后再输入cd ~/.ssh之后输入cat id_rsa.pub会出现一串以ssh-rsa开头的一段公钥。复制打开你的github在设置中找到SSH and GPG keys建立一个新的SSH keys。 配置博客前面的做好之后打开你之前建立的博客文件夹找到一个名为_config.yml（冒号之后都是有一个半角空格）1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到Git bash进入blog，执行123hexo cleanhexo ghexo s 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。打开浏览器http://localhost:4000就可以看到你的博客了 部署项目先安装：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）安装好后执行123hexo cleanhexo generatehexo deploy 在浏览器中输入http://你的用户名.github.io就可以看到你的个人博客啦，是不是很兴奋！]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React快速入门]]></title>
    <url>%2F2018%2F08%2F11%2FReact01%2F</url>
    <content type="text"><![CDATA[开发环境搭建首先搭建node环境（后面细讲），然后到react官网看官方文档里的Create React App里的两端代码，我是在Windows下所以打开cmd输入npx create-react-app my-app之后cd到安装目录下执行npm start就自动构建成了新的项目，至于webpack啥的还没开始学就先不讲了。 精简代码在npm start执行后自动在浏览器打开了一个页面，找到你之前创建了的文件夹，src文件里存放着代码，index.js是这个项目的入口文件，registerServiceWorker是pwa（离线页面），现在用不到可以先精简了，还有import ./index。css这个是样式文件也可以精简了，最后留下三句话就够了import React, {Component,Fragment} from &#39;react&#39;;import TodoItem from &#39;./TodoItem&#39;; 什么是组件React是基于组件的框架，组件就是将网页局部化，将一个大的网页分成大的几块这就是组件，这些组件再拆分成小组件。打开index.js组件就是从 import A from &quot;./A&quot;引入而ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&#39;root&#39;));则是在一个id为root的地方进行渲染 JSXJavaScript与xml，在代码中可以轻松的使用html标签而不会报错，而想使用JavaScript的时候加一个{}就好了，但是只可以是表达式而不是语句。eg：1234567891011121314151617class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); this.handleItemClick=this.handleItemClick.bind(this); &#125; handleItemClick()&#123; this.props.handDelete(this.props.index); &#125; render()&#123; const &#123;content&#125;=this.props; return ( &lt;div&gt; &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;content&#125;&lt;/li&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About css选择器]]></title>
    <url>%2F2018%2F08%2F02%2FAbout-css%2F</url>
    <content type="text"><![CDATA[写在前面的话在我看来css是我在编程过程中最头疼的几个问题之一，首先是定位问题，对css元素、选择器不熟悉的话肯定要出问题，其次就是浮动问题，最后就是响应式布局，这里我主要就是记录css，其他的后面再单独记录。 css的选择器css的选择器大致可以分为： 元素选择器元素选择器，最基本的选择器，如果设置 HTML 的样式，选择器通常将是某个 HTML 元素，比如 p、h1、em、a，甚至可以是 html 本身。eg:123html &#123;color:black;&#125;h1 &#123;color:blue;&#125;h2 &#123;color:silver;&#125; 类选择器类选择器，类选择器允许以一种独立于文档元素的方式来指定样式。在使用类选择器之前，需要修改具体的文档标记，以便类选择器正常工作。为了将类选择器的样式与元素关联，必须将 class 指定为一个适当的值。通过class来获取事先指定好的样式。eg:1&lt;h1 class=&quot;important&quot;&gt;&lt;/css&gt; 1.important &#123;color:red;&#125; ID选择器ID选择器，ID 选择器类似于类选择器，不过也有一些重要差别，ID 选择器前面有一个#号，ID 选择器不引用 class 属性的值，毫无疑问，它要引用 id 属性中的值。与类不同，在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次。不同于类选择器，ID 选择器不能结合使用，因为 ID 属性不允许有以空格分隔的词列表。eg:1&lt;p id=&quot;intro&quot;&gt;hello world.&lt;/p&gt; 1*#intro &#123;font-weight:bold;&#125; 属性选择器属性选择器，CSS 2 引入了属性选择器。属性选择器可以根据元素的属性及属性值来选择元素，这个东西我并不经常用，因为我感觉比较玄，一般都是用上面几种。这个就大致讲一下用法，大概就是指定一个标签，然后这种标签带有特定属性的都被选择。eg:1234a[href][title] &#123;color:red;&#125;//可以只对有 href 属性的锚（a 元素）应用样式img[alt] &#123;border: 5px solid red;&#125;//可以对所有带有 alt 属性的图像应用样式，从而突出显示这些有效的图像 后代选择器后代选择器，根据上下文选择元素，我们可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。后代选择器的功能极其强大。有了它，可以使 HTML 中不可能实现的任务成为可能。假设有一个文档，其中有一个边栏，还有一个主区。边栏的背景为蓝色，主区的背景为白色，这两个区都包含链接列表。不能把所有链接都设置为蓝色，因为这样一来边栏中的蓝色链接都无法看到。eg：12345css部分div.sidebar &#123;background:blue;&#125;div.maincontent &#123;background:white;&#125;div.sidebar a:link &#123;color:white;&#125;div.maincontent a:link &#123;color:blue;&#125; 12345678910111213141516171819html部分&lt;ul&gt; &lt;li&gt;List item 1 &lt;ol&gt; &lt;li&gt;List item 1-1&lt;/li&gt; &lt;li&gt;List item 1-2&lt;/li&gt; &lt;li&gt;List item 1-3 &lt;ol&gt; &lt;li&gt;List item 1-3-1&lt;/li&gt; &lt;li&gt;List item &lt;em&gt;1-3-2&lt;/em&gt;&lt;/li&gt; &lt;li&gt;List item 1-3-3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 1-4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt; 子元素选择器子元素选择器，这个选择器与后代选择器类似，不过区别于后代选择器它只能选择某个元素的子元素。eg:1h1 &gt; strong &#123;color:red;&#125; 1&lt;h1&gt; hello &lt;strong&gt;world&lt;/strong&gt;&lt;/h1&gt; 相邻兄弟选择器相邻兄弟选择器,子元素选择器、后代选择器、相邻兄弟选择器这三个选择器效果都差不多，只不过一个选择器比一个选择器缩小了范围而已，后代选择的是所有后代，子元素是某个元素的所有子元素，相邻兄弟选择器是选择下一个或者上一个。eg:12h1 + p &#123;margin-top:50px;&#125;//选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素 就写到这里吧，css的选择器是比较关键的，其他的过几天再总结，就这样~]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About html]]></title>
    <url>%2F2018%2F08%2F02%2Fabout-html%2F</url>
    <content type="text"><![CDATA[写在前面的一些话入门前端也有不短的一段时间了自己前前后后也看了许多教程和视频，也算是入了前端的坑了吧，感觉前端学习的东西太杂了怕自己捋不清所以写下笔记记录一下。 Html DOM html在我看来如果不算H5的话它就好比一幢楼房的钢筋部分，html的语法并不难甚至可以说是很简单，标签也越来越语义化，但是学习html是为了让你对DOM树有一种感觉，就好像在开始建造房屋时你得想好需要建多高每层要搭建一些什么东西。在一些小页面可能无法体现，但是到了大型网站这就变得至关重要了。 这其实也是一个节点图，文档中的所有内容、所以标签都可以视为一个节点，这样就可以利用节点做许多操作，例如： ① 查询某个元素 ② 查询某个元素的祖先、兄弟以及后代元素 ③ 获取、修改元素的属性 ④ 获取、修改元素的内容 ⑤ 创建、插入和删除元素 关于这些操作涉及到了JavaScript所以这里就不细讲了，总之学习html在掌握语法的同时也要构建一种DOM树的思想。 标签的用法总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;a&gt; 定义锚。&lt;abbr&gt; 定义缩写。&lt;acronym&gt; 定义只取首字母的缩写。&lt;address&gt; 定义文档作者或拥有者的联系信息。&lt;applet&gt; 不赞成使用。定义嵌入的 applet。&lt;area&gt; 定义图像映射内部的区域。&lt;article&gt; 定义文章。&lt;aside&gt; 定义页面内容之外的内容。&lt;audio&gt; 定义声音内容。&lt;b&gt; 定义粗体字。&lt;base&gt; 定义页面中所有链接的默认地址或默认目标。&lt;basefont&gt; 不赞成使用。定义页面中文本的默认字体、颜色或尺寸。&lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置。&lt;bdo&gt; 定义文字方向。&lt;big&gt; 定义大号文本。&lt;blockquote&gt; 定义长的引用。&lt;body&gt; 定义文档的主体。&lt;br&gt; 定义简单的折行。&lt;button&gt; 定义按钮 (push button)。&lt;canvas&gt; 定义图形。&lt;caption&gt; 定义表格标题。&lt;center&gt; 不赞成使用。定义居中文本。&lt;cite&gt; 定义引用(citation)。&lt;code&gt; 定义计算机代码文本。&lt;col&gt; 定义表格中一个或多个列的属性值。&lt;colgroup&gt; 定义表格中供格式化的列组。&lt;command&gt; 定义命令按钮。&lt;datalist&gt; 定义下拉列表。&lt;dd&gt; 定义定义列表中项目的描述。&lt;del&gt; 定义被删除文本。&lt;details&gt; 定义元素的细节。&lt;dir&gt; 不赞成使用。定义目录列表。&lt;div&gt; 定义文档中的节。&lt;dfn&gt; 定义定义项目。&lt;dialog&gt; 定义对话框或窗口。&lt;dl&gt; 定义定义列表。&lt;dt&gt; 定义定义列表中的项目。&lt;em&gt; 定义强调文本。&lt;embed&gt; 定义外部交互内容或插件。&lt;fieldset&gt; 定义围绕表单中元素的边框。&lt;figcaption&gt; 定义 figure 元素的标题。&lt;figure&gt; 定义媒介内容的分组，以及它们的标题。&lt;font&gt; 不赞成使用。定义文字的字体、尺寸和颜色。&lt;footer&gt; 定义 section 或 page 的页脚。&lt;form&gt; 定义供用户输入的 HTML 表单。&lt;frame&gt; 定义框架集的窗口或框架。&lt;frameset&gt; 定义框架集。&lt;h1to &lt;h6&gt; 定义 HTML 标题。&lt;head&gt; 定义关于文档的信息。&lt;header&gt; 定义 section 或 page 的页眉。&lt;hr&gt; 定义水平线。&lt;html&gt; 定义 HTML 文档。&lt;i&gt; 定义斜体字。&lt;iframe&gt; 定义内联框架。&lt;img&gt; 定义图像。&lt;input&gt; 定义输入控件。&lt;ins&gt; 定义被插入文本。&lt;isindex&gt; 不赞成使用。定义与文档相关的可搜索索引。&lt;kbd&gt; 定义键盘文本。&lt;keygen&gt; 定义生成密钥。&lt;label&gt; 定义 input 元素的标注。&lt;legend&gt; 定义 fieldset 元素的标题。&lt;li&gt; 定义列表的项目。&lt;link&gt; 定义文档与外部资源的关系。&lt;map&gt; 定义图像映射。&lt;mark&gt; 定义有记号的文本。&lt;menu&gt; 定义命令的列表或菜单。&lt;menuitem&gt; 定义用户可以从弹出菜单调用的命令/菜单项目。&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;meter&gt; 定义预定义范围内的度量。&lt;nav&gt; 定义导航链接。&lt;noframes&gt; 定义针对不支持框架的用户的替代内容。&lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。&lt;object&gt; 定义内嵌对象。&lt;ol&gt; 定义有序列表。&lt;optgroup&gt; 定义选择列表中相关选项的组合。&lt;option&gt; 定义选择列表中的选项。&lt;output&gt; 定义输出的一些类型。&lt;p&gt; 定义段落。&lt;param&gt; 定义对象的参数。&lt;pre&gt; 定义预格式文本。&lt;progress&gt; 定义任何类型的任务的进度。&lt;q&gt; 定义短的引用。&lt;rp&gt; 定义若浏览器不支持 ruby 元素显示的内容。&lt;rt&gt; 定义 ruby 注释的解释。&lt;ruby&gt; 定义 ruby 注释。&lt;s&gt; 不赞成使用。定义加删除线的文本。&lt;samp&gt; 定义计算机代码样本。&lt;script&gt; 定义客户端脚本。&lt;section&gt; 定义 section。&lt;select&gt; 定义选择列表（下拉列表）。&lt;small&gt; 定义小号文本。&lt;source&gt; 定义媒介源。&lt;span&gt; 定义文档中的节。&lt;strike&gt; 不赞成使用。定义加删除线文本。&lt;strong&gt; 定义强调文本。&lt;style&gt; 定义文档的样式信息。&lt;sub&gt; 定义下标文本。&lt;summary&gt; 为 &lt;details元素定义可见的标题。&lt;sup&gt; 定义上标文本。&lt;table&gt; 定义表格。&lt;tbody&gt; 定义表格中的主体内容。&lt;td&gt; 定义表格中的单元。&lt;textarea&gt; 定义多行的文本输入控件。&lt;tfoot&gt; 定义表格中的表注内容（脚注）。&lt;th&gt; 定义表格中的表头单元格。&lt;thead&gt; 定义表格中的表头内容。&lt;time&gt; 定义日期/时间。&lt;title&gt; 定义文档的标题。&lt;tr&gt; 定义表格中的行。&lt;track&gt; 定义用在媒体播放器中的文本轨道。&lt;tt&gt; 定义打字机文本。&lt;u&gt; 不赞成使用。定义下划线文本。&lt;ul&gt; 定义无序列表。&lt;var&gt; 定义文本的变量部分。&lt;video&gt; 定义视频。&lt;wbr&gt; 定义可能的换行符。 最后一点，总结在中干竞选的时候被问到的几个问题：1、盒子模型内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 2、块元素和行内元素在我看来就是换行和不换行的问题，块级元素需要换行而行内元素不需要。通过css可以进行转换12display:block; /*转换为块级*/display:inline; /*转换为行内*/ 3、权重问题CSS权重是由四个数值决定，内联样式、ID选择器、类选择器、类型选择器和伪元素选择器。第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为100。第三等：代表类，伪类和属性选择器，如.content，权值为10。第四等：代表类型选择器和伪元素选择器，如div p，权值为1。最后把这些值加起来，再就是当前元素的权重了。权重算出来了，但是某个元素到底用哪个样式，还有3个规则,：第一、如果样式上加有!important标记，例如：1p&#123; color: gray !important&#125; 那么始终采用这个标记的样式。第二、匹配的内容按照CSS权重排序，权重大的优先；可以看到，CSS权重只是决定应用哪个样式的其中一个步骤，不过这个步骤是最复杂的，上面已经说过了。第三、如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：12h1 &#123;color: blue&#125;h1 &#123;color: red&#125; 最终胜出的是color: red。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之表格输出]]></title>
    <url>%2F2018%2F04%2F19%2FQt4%2F</url>
    <content type="text"><![CDATA[&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x5728;C&#x4E2D;&#x7684;&#x7B97;&#x6CD5;&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x4E3B;&#x8981;&#x662F;&#x7531;&#x6211;&#x7684;&#x961F;&#x53CB; pedant &#x8D1F;&#x8D23;&#xFF0C;&#x5728;C&#x7684;&#x73AF;&#x5883;&#x4E2D;&#x7684;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110include &lt;stdio.h&gt;int save[8][8]=&#123;0,0&#125;; int table[1000][8] = &#123;0,0&#125;;int r = 1;int day[8] = &#123;0&#125;; void store()&#123; //找到一个方案之后储存到数组table中int i,j; for(j=1;j&lt;8;j++)&#123; for(i=1;i&lt;8;i++)&#123; if(save[i][j]==2) table[r][j] = i; &#125;&#125;r++;&#125;int can(int k,int j)&#123; //对于第k名员工在第J天是否可以休息进行判断int s=0,i;for(i=1;i&lt;8;i++) if(save[k][i]==2) s++;if(s&gt;1) return 0;for(s=0,i=1;i&lt;8;i++) if(save[i][j]==2) s++;if(s&gt;1) return 0; return 1;&#125; //符合要求，k在j可以休息，则返回1void dfs(int k)&#123; //深度优先搜索，从初始位置开始进行遍历，即从第K名员工开始int i,j;for(j=1;j&lt;8;j++) if(save[k][j]==1)&#123; //第k名员工将j设为自己的休息日 save[k][j]=2; //save[i][j]已经遍历过 if(can(k,j))&#123; //如果这天满足条件 if(k==7) //找到一个方案，储存到save中 store(); else dfs(k+1); //继续向下遍历 &#125; save[k][j]=1; //回溯，遍历下一个不同的休息日 &#125;&#125;int main()&#123;int i = 1,j = 1,k,temp[10][10] = &#123;0,0&#125;,cotp[8][8]; //储存初始数据的格式int jud = 1;char ch; for( ;i &lt; 8; i++)&#123; //员工信息的初始化，i代表各个员工的key，j代表该i对应的员工请假的日期。 do &#123; scanf(&quot;%d&quot;,&amp;save[i][j]); j++;&#125; while((ch = getchar())!=&apos;\n&apos;); j = 1; &#125;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125; &#125;if(jud)&#123; dfs(1); printf(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i = 1; i&lt;r; i++)&#123; //和qt交换数据时把print改成赋值，把putchar取消即可 for(j = 1; j&lt;8; j++)&#123; printf(&quot;%d &quot;,table[i][j]); &#125; putchar(&apos;\n&apos;);&#125;&#125;else&#123; printf(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) printf(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 printf(&quot;has no worker&quot;);&#125; getchar(); getchar();return 0;&#125; &#x6539;&#x5199;&#x4EE3;&#x7801;&#x5F53;&#x7136;&#xFF0C;&#x5728;Qt&#x4E2D;&#x76F4;&#x63A5;&#x5957;&#x7528;C&#x7684;&#x4EE3;&#x7801;&#x662F;&#x884C;&#x4E0D;&#x901A;&#x7684;&#xFF0C;&#x7279;&#x522B;&#x662F;&#x8FD8;&#x5B9A;&#x4E49;&#x4E86;&#x5176;&#x4ED6;&#x7684;&#x51FD;&#x6570;&#x3002;&#x6240;&#x4EE5;&#x5E94;&#x5F53;&#x8FDB;&#x884C;&#x9002;&#x5F53;&#x7684;&#x6539;&#x5199;&#xFF0C;&#x9996;&#x5148;&#x5C31;&#x9700;&#x8981;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x7684;private slots:&#x4E2D;&#x8FDB;&#x884C;&#x58F0;&#x660E; 1234private slots: void dfs(int k); int can(int k, int j); void store(); &#x58F0;&#x660E;&#x8FC7;&#x540E;&#x51FD;&#x6570;&#x518D;&#x5728;form.cpp&#x4E2D;&#x7F16;&#x5199;&#x5373;&#x53EF;&#xFF0C;&#x518D;&#x5BF9;&#x8F93;&#x5165;&#x8F93;&#x51FA;&#x90E8;&#x5206;&#x8FDB;&#x884C;&#x7B26;&#x5408;Qt&#x98CE;&#x683C;&#x7684;&#x6539;&#x7F16;&#x5373;&#x53EF;&#xFF0C;&#x5177;&#x4F53;&#x5728;Qt&#x4E2D;&#x8FD0;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int i=1,temp[10][10] = &#123; 0, 0 &#125;;int nnn=1;int m=0,e=0;QSqlQuery query;QString select_sql = &quot;select one, two, three, four, five, six, seven from work&quot;;if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125;else &#123; while(query.next()) //读入数据 &#123; save[i][1] = query.value(0).toInt(); save[i][2] = query.value(1).toInt(); save[i][3] = query.value(2).toInt(); save[i][4] = query.value(3).toInt(); save[i][5] = query.value(4).toInt(); save[i][6] = query.value(5).toInt(); save[i][7] = query.value(6).toInt(); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 i=i+1; &#125; &#125;int j = 1,k,cotp[8][8]; //储存初始数据的格式int jud = 1;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125;&#125;if(jud)&#123; dfs(1); qDebug(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;; if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 nnn=nnn+1; //e=e+1; &#125; &#125; m=m+1; &#125;&#125;else&#123; qDebug(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) //qDebug(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 QMessageBox::warning(this,tr(&quot;提示&quot;),QString(&quot;星期%1无法安排值班！&quot;).arg(i),QMessageBox::Yes); &#125;n2=r-1;qDebug(&quot;%d &quot;,m); &#x7531;&#x4E0A;&#x53EF;&#x4EE5;&#x770B;&#x51FA;C&#x7684;&#x7F16;&#x7801;&#x98CE;&#x683C;&#x5E76;&#x4E0D;&#x9002;&#x7528;&#x4E8E;Qt&#x5C3D;&#x7BA1;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#x4E86;&#xFF0C;&#x4F46;&#x662F;&#x4ECD;&#x7136;&#x5B58;&#x5728;&#x591A;&#x4E2A;&#x8B66;&#x544A;&#x65E0;&#x6CD5;&#x6D88;&#x9664;&#xFF0C;&#x6240;&#x4EE5;&#x8FD8;&#x662F;&#x5C3D;&#x91CF;&#x7528;C++&#x5427;&#xFF0C;&#x4E0D;&#x7136;&#x6539;&#x5199;&#x5F88;&#x9EBB;&#x70E6;&#x3002; &#x8868;&#x683C;&#x90E8;&#x5206;&#x6211;&#x7ED8;&#x5236;&#x8868;&#x683C;&#x91C7;&#x7528;&#x7684;&#x662F;&#x51FD;&#x6570;&#x7ED8;&#x56FE;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x63A7;&#x4EF6;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x597D;&#x5904;&#x662F;&#x53EF;&#x4EE5;&#x7CBE;&#x786E;&#x7684;&#x63A7;&#x5236;&#x8868;&#x683C;&#x5927;&#x5C0F;&#xFF0C;&#x9AD8;&#x5BBD;&#x7B49;&#x7B49;&#x3002; &#x8868;&#x683C;&#x7684;&#x521B;&#x5EFA;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x9700;&#x8981;&#x5148;&#x521B;&#x7ACB;&#x4E00;&#x4E2A;&#x9002;&#x5F53;&#x5927;&#x5C0F;&#x7684;tablewidget&#xFF0C;&#x7136;&#x540E;&#x518D;&#x521B;&#x5EFA;&#x5B57;&#x6BB5;&#x5B9A;&#x4E49;&#x5217;&#x5BBD;&#x884C;&#x5BBD;&#xFF0C;&#x6211;&#x7F16;&#x5199;&#x8FD9;&#x4E00;&#x6BB5;&#x5148;&#x662F;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;creatable&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x51FD;&#x6570;&#x4E2D;&#x8FDB;&#x884C;&#x521B;&#x5EFA;&#xFF0C;&#x5F53;&#x7136;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x53EF;&#x4EE5;&#x653E;&#x5165;&#x4E3B;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 12345678QTableWidget *tabl = new QTableWidget(this);tabl-&gt;setColumnCount(7); //设置列数tabl-&gt;setRowCount(5040); //设置行数/*设置列名*/QStringList headers;headers&lt;&lt;&quot;星期一&quot;&lt;&lt;&quot;星期二&quot;&lt;&lt;&quot;星期三&quot;&lt;&lt;&quot;星期四&quot;&lt;&lt;&quot;星期五&quot;&lt;&lt;&quot;星期六&quot;&lt;&lt;&quot;星期日&quot;;tabl-&gt;setHorizontalHeaderLabels(headers);tabl-&gt;resize(600,500); //设置大小尺寸 &#x8868;&#x683C;&#x6570;&#x636E;&#x7684;&#x8F93;&#x51FA;&#x5728;C&#x4E2D;&#x7684;&#x8868;&#x683C;&#x8F93;&#x51FA;&#x7528;&#x7684;&#x662F;printf&#xFF0C;&#x800C;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x4E2D;&#x9700;&#x8981;&#x7528;&#x5230;&#x7684;&#x8BED;&#x53E5;&#x662F;tabl-&gt;setItem&#xFF0C;&#x56E0;&#x6B64;&#x5C31;&#x9700;&#x8981;&#x5BF9;&#x8F93;&#x51FA;&#x6570;&#x636E;&#x8FDB;&#x884C;&#x6539;&#x5199;&#xFF0C;&#x800C;&#x5728;&#x8868;&#x683C;&#x4E2D;&#x7684;&#x8F93;&#x51FA;&#x53EA;&#x80FD;&#x6309;&#x987A;&#x5E8F;&#x8FDB;&#x884C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EA;&#x80FD;&#x6539;&#x53D8;&#x8981;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x7684;&#x6570;&#x636E;&#x7684;&#x987A;&#x5E8F;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 123456789101112131415161718192021for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;;//选择数据库 if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; //qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); nnn=nnn+1; &#125; &#125; m=m+1; &#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之主界面操作数据库]]></title>
    <url>%2F2018%2F04%2F19%2FQt3%2F</url>
    <content type="text"><![CDATA[&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x8BE5;&#x90E8;&#x5206;&#x4E3A;&#x672C;&#x6B21;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x6700;&#x4E3A;&#x5173;&#x952E;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x9996;&#x5148;&#x662F;&#x4F11;&#x606F;&#x65E5;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x6211;&#x4EEC;&#x5229;&#x7528;checkbox&#x63A7;&#x4EF6;&#x6765;&#x6536;&#x96C6;&#x7528;&#x6237;&#x6240;&#x9009;&#x62E9;&#x7684;&#x4F11;&#x606F;&#x65E5;&#x671F;&#xFF0C;&#x5C06;&#x5176;&#x50A8;&#x5B58;&#x5728;&#x8BBE;&#x7F6E;&#x597D;&#x7684;&#x4E03;&#x4E2A;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#x518D;&#x5C06;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;idcard&#x8FDB;&#x884C;&#x5916;&#x90E8;&#x8C03;&#x7528;&#x4F5C;&#x4E3A;&#x5199;&#x5165;&#x6570;&#x636E;&#x7684;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x5E93;&#x7531;7&#x4E2A;&#x6570;&#x5916;&#x52A0;id&#x3001;workname&#x3001;workcall&#x7EC4;&#x6210;&#x3002; &#x4E3B;&#x754C;&#x9762;&#x90E8;&#x5206;&#x4E3B;&#x754C;&#x9762;&#x4E3B;&#x8981;&#x6D89;&#x53CA;&#x4E24;&#x4E2A;&#x96BE;&#x70B9;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x3002; Checkbox&#x7684;&#x4F7F;&#x7528;&#x5BF9;&#x4E8E;Checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x5173;&#x952E;&#x7684;&#x5730;&#x65B9;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x5224;&#x65AD;&#x8FD9;&#x4E2A;&#x63A7;&#x4EF6;&#x6709;&#x6CA1;&#x6709;&#x88AB;&#x9009;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789if (state == Qt::Checked) // 选中 &#123; a1=1; qDebug()&lt;&lt;&quot;周一ok!&quot;; &#125;else //未选 &#123; a1=0; &#125; &#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x6211;&#x4EEC;&#x5C06;7&#x4E2A;&#x4F11;&#x606F;&#x65E5;&#x6240;&#x5BF9;&#x5E94;&#x7684;&#x63A7;&#x4EF6;&#x7684;&#x69FD;&#x51FD;&#x6570;&#x7F16;&#x5199;&#x597D;&#x4E86;&#x4E4B;&#x540E;&#xFF0C;7&#x4E2A;&#x6570;&#x636E;&#x5DF2;&#x7ECF;&#x5B58;&#x5165;&#x6211;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x8981;&#x505A;&#x7684;&#x5C31;&#x662F;&#x5C06;7&#x4E2A;&#x53D8;&#x91CF;&#x5B58;&#x5165;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool ok=database.open();if(idcard==0)&#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;管理员无法进行该操作！&quot;),QMessageBox::Yes);&#125;else&#123; if (!ok) &#123; qDebug() &lt;&lt; &quot;Error: Failed to connect database.&quot; &lt;&lt; database.lastError(); &#125; else &#123; // do something &#125; QSqlQuery query; //插入数据 query.prepare(insert_sql); query.addBindValue(idcard); //id query.addBindValue(a1); //1 query.addBindValue(a2); //2 query.addBindValue(a3); //3 query.addBindValue(a4); //4 query.addBindValue(a5); //5 query.addBindValue(a6); //6 query.addBindValue(a7); //7 query.addBindValue(workname); //workname query.addBindValue(workcall); //workcall QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;提交信息成功！&quot;),QMessageBox::Yes); if(!query.exec()) &#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;无法重复提交信息！&quot;),QMessageBox::Yes); qDebug()&lt;&lt;query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;inserted!&quot;; &#125;&#125;//核心语句仅为 QSqlQuery query; query.prepare(insert_sql); query.addBindValue(写入的变量名); &#x5176;&#x5B9E;&#x5229;&#x7528;Qt&#x5BF9;sqlite&#x7684;&#x64CD;&#x4F5C;&#x5E76;&#x4E0D;&#x590D;&#x6742;&#xFF0C;&#x6838;&#x5FC3;&#x90E8;&#x5206;&#x5176;&#x5B9E;&#x5341;&#x5206;&#x7B80;&#x5355;&#xFF0C;&#x5927;&#x90E8;&#x5206;&#x521D;&#x5B66;&#x8005;&#xFF08;&#x5305;&#x62EC;&#x6211;&#xFF09;&#x90FD;&#x5C06;&#x6570;&#x636E;&#x5E93;&#x60F3;&#x8C61;&#x7684;&#x592A;&#x96BE;&#x592A;&#x96BE;&#x4E86;&#xFF0C;&#x5176;&#x5B9E;&#x975E;&#x4E5F;&#x3002;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之注册与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt2%2F</url>
    <content type="text"><![CDATA[&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x662F;&#x6211;&#x8BA4;&#x4E3A;&#x6BD4;&#x8F83;&#x96BE;&#x7684;&#x90E8;&#x5206;&#x4EC5;&#x6B21;&#x4E8E;&#x540E;&#x9762;&#x6392;&#x73ED;&#x8868;&#x683C;&#x7684;&#x8F93;&#x51FA;&#xFF0C;&#x96BE;&#x70B9;&#x4E3B;&#x8981;&#x662F;&#x63D2;&#x5165;&#x6570;&#x636E;&#x548C;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x91CD;&#x590D;&#x8FD9;&#x4E24;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x67E5;&#x8BE2;&#x6570;&#x636E;&#x4E4B;&#x524D;&#x5728;&#x767B;&#x5F55;&#x90E8;&#x5206;&#x5C31;&#x6709;&#x63D0;&#x8FC7;&#x4ECE;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x90A3;&#x4E2A;&#x662F;&#x901A;&#x8FC7;&#x67E5;&#x8BE2;name&#x5B57;&#x6BB5;&#x6765;&#x5B9E;&#x73B0;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x627E;&#x5230;&#x5BC6;&#x7801;&#xFF0C;&#x8FD9;&#x4E2A;&#x5927;&#x540C;&#x5C0F;&#x5F02;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x6765;&#x67E5;&#x627E;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x4E0E;&#x524D;&#x9762;&#x7C7B;&#x4F3C;&#xFF0C;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D58;&#x8FF0;&#x4E86;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142//查询部分数据(name)if(!sql_query.exec(select_sql))&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(1) &#123; if(sql_query.next()) //name有数据 &#123; QString name = sql_query.value(&quot;name&quot;).toString(); qDebug()&lt;&lt;QString(&quot;name=%1&quot;).arg(name); if(ui-&gt;nameLineEdit-&gt;text()==name) //用户名已经存在 &#123; ui-&gt;nameLineEdit-&gt;setFocus(); nameFlag=false; break; &#125; else &#123; //newname=ui-&gt;nameLineEdit-&gt;text(); nameFlag=true; &#125; &#125; else &#123; //name列为空 nameFlag=true; break; &#125; &#125;&#125;newchatid=max_id+1;if(nameFlag==true) newname=ui-&gt;nameLineEdit-&gt;text();else return;if(passwdFlag==true) newpasswd=ui-&gt;passwd1LineEdit-&gt;text();else return; &#x63D2;&#x5165;&#x6570;&#x636E;&#x5F53;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x800C;&#x4E14;&#x7528;&#x6237;&#x6CE8;&#x518C;&#x6210;&#x529F;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x9700;&#x8981;&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x63D2;&#x5165;&#x65B0;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BBE;&#x5B9A;&#x4E00;&#x4E2A;id&#xFF0C;&#x901A;&#x8FC7;&#x6700;&#x5927;id&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5C3E;&#x90E8; 123456789101112131415//查询最大idmax_id = 0;sql_query.prepare(select_max_sql);if(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(sql_query.next()) &#123; max_id = sql_query.value(0).toInt(); qDebug()&lt;&lt;QString(&quot;max chatid:%1&quot;).arg(max_id);//输出最大ID在Debug界面 &#125;&#125; &#x6700;&#x5927;ID&#x627E;&#x5230;&#x540E;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x518D;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;newID=max_id+1&#x6765;&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x5C3E;&#x90E8;&#x7684;&#x4E0B;&#x4E00;&#x7EC4;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E; 1234567891011121314151617//插入数据sql_query.prepare(insert_sql);sql_query.addBindValue(newID); //idsql_query.addBindValue(newpasswd); //passwdsql_query.addBindValue(newname); //namesql_query.addBindValue(newemail); //emailsql_query.addBindValue(0); //historyif(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; qDebug()&lt;&lt;&quot;inserted!&quot;; //插入成功&#125;this-&gt;close(); &#x5F39;&#x7A97;&#x5728;&#x4E4B;&#x524D;&#x7684;&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;&#x767B;&#x5F55;&#x9519;&#x8BEF;&#x3001;&#x7528;&#x6237;&#x540D;&#x91CD;&#x590D;&#x7B49;&#x4FE1;&#x606F;&#x9700;&#x8981;&#x4F20;&#x8FBE;&#x7ED9;&#x4F7F;&#x7528;&#x8005;&#xFF0C;&#x8FD9;&#x65F6;&#x5C31;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5F39;&#x7A97;&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x5165; QMessageBox &#x5373;&#x53EF;&#x3002; 123QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;喂！\n 你两次密码输的不一样，你是不是傻？！&quot;),QMessageBox::Yes);ui-&gt;passwd2LineEdit-&gt;clear();//清空密码输入栏ui-&gt;passwd2LineEdit-&gt;setFocus();//将鼠标定位到密码输入栏]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之登录与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt1%2F</url>
    <content type="text"><![CDATA[&#x5728;&#x4E0A;&#x4E00;&#x5468;&#x7684;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x5468;&#x8FD0;&#x7528;Qt&#x5BF9;&#x8001;&#x5E08;&#x7ED9;&#x51FA;&#x7684;&#x8BFE;&#x9898;(&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;)&#x8FDB;&#x884C;&#x4E86;UI&#x754C;&#x9762;&#x7684;&#x8BBE;&#x8BA1;&#xFF0C;&#x5728;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#x6709;&#x4E86;&#x4E0D;&#x5C0F;&#x7684;&#x6536;&#x83B7;&#xFF0C;&#x7279;&#x6B64;&#x4E0E;&#x5927;&#x5BB6;&#x4E00;&#x8D77;&#x5206;&#x4EAB;&#xFF0C;&#x4E0D;&#x559C;&#x52FF;&#x55B7;&#xFF01; &#x8BBE;&#x8BA1;&#x601D;&#x8DEF;&#x8BE5;&#x8BFE;&#x9898;&#x4E3A;&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;&#xFF0C;&#x5BF9;&#x767B;&#x5F55;&#x3001;&#x6CE8;&#x518C;&#x3001;&#x4F11;&#x606F;&#x65E5;&#x9009;&#x62E9;&#x3001;&#x6392;&#x73ED;&#x5747;&#x6709;&#x8981;&#x6C42;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x8BBE;&#x7F6E;&#x4E86;&#x56DB;&#x4E2A;&#x7A97;&#x53E3;&#x6765;&#x5206;&#x522B;&#x5BF9;&#x5E94;&#x56DB;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x767B;&#x5F55;&#x90E8;&#x5206;&#x9996;&#x5148;&#x662F;&#x767B;&#x5F55;&#x90E8;&#x5206;&#xFF0C;&#x65E2;&#x7136;&#x662F;&#x767B;&#x5F55;&#x90A3;&#x4E48;&#x80AF;&#x5B9A;&#x4F1A;&#x6D89;&#x53CA;&#x5230;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x7684;&#x5339;&#x914D;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FD9;&#x91CC;&#x91C7;&#x7528;&#x7684;&#x662F;sqlite&#x4F5C;&#x4E3A;&#x6570;&#x636E;&#x5E93;&#x6765;&#x50A8;&#x5B58;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x4EE5;&#x53CA;&#x7535;&#x8BDD;&#x53F7;&#x7801;&#x7B49;&#x6570;&#x636E;&#x3002;&#x6D89;&#x53CA;&#x5230;&#x6570;&#x636E;&#x5E93;&#x4E0E;Qt&#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x4EA4;&#x4E92;&#xFF0C;&#x5177;&#x4F53;&#x6570;&#x636E;&#x5E93;&#x7684;&#x521B;&#x5EFA;&#x3001;&#x8F93;&#x51FA;&#x548C;&#x8F93;&#x5165;&#x540E;&#x9762;&#x4F1A;&#x8BB2;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x8BB2;Qt&#x548C;&#x6570;&#x636E;&#x7684;&#x8FDE;&#x63A5;&#x3002; &#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x5728;login.cpp&#x4E2D; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//打开数据库if(!database.open())&#123; qDebug()&lt;&lt;database.lastError(); //打开失败 qFatal(&quot;failed to connect.&quot;) ;&#125;else&#123; qDebug()&lt;&lt;&quot;open seccess&quot;; QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效 sql_query.prepare(select_table); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; QString tableName; while(sql_query.next()) &#123; tableName = sql_query.value(0).toString(); qDebug()&lt;&lt;tableName; if(tableName.compare(&quot;user&quot;)) //打开名为user的数据库 &#123; tableFlag=false; qDebug()&lt;&lt;&quot;table is not exist&quot;; &#125; else &#123; tableFlag=true; qDebug()&lt;&lt;&quot;table is exist&quot;; &#125; &#125; &#125; if(tableFlag==false) //该数据库不存在就创建一个user的数据库 &#123; sql_query.prepare(create_sql); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;table created!&quot;; &#125; &#125; //database.close();&#125;//先判断数据库能否打开再判断是否数据库存在。 &#x8FD9;&#x4E00;&#x6BB5;&#x4EE3;&#x7801;&#x653E;&#x5728;Login::Login(QWidget *parent) :&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;open seccess&#xFF0C;&#x521B;&#x5EFA;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;table created!&#xFF0C;&#x6253;&#x5F00;&#x5931;&#x8D25;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;failed to connect.&#x3002; &#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8BE5;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8F83;&#x4E3A;&#x7B80;&#x964B;&#xFF0C;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x662F;&#x901A;&#x8FC7;&#xFF1A; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x7528;&#x6237;&#x540D;&#x3002; &#x5BF9;&#x6570;&#x636E;&#x5E93;&#x8FDB;&#x884C;&#x68C0;&#x7D22;&#xFF0C;&#x82E5;&#x53EF;&#x4EE5;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;&#x5BC6;&#x7801;&#x5219;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5BC6;&#x7801;&#x548C;ID&#xFF0C;&#x82E5;&#x4E0D;&#x80FD;&#x627E;&#x5230;&#x5219;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x3002; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x5BC6;&#x7801;&#x4E0E;&#x4E4B;&#x524D;&#x68C0;&#x7D22;&#x51FA;&#x6765;&#x7684;&#x5BC6;&#x7801;&#x8FDB;&#x884C;&#x5339;&#x914D;&#x3002; &#x5224;&#x65AD;&#x662F;&#x5426;&#x767B;&#x5F55;&#x6210;&#x529F; 12345678910111213141516171819202122if(matchFlag==false)&#123;//用户名错误qDebug()&lt;&lt;&quot;name invalid&quot;;&#125;else&#123;if(usr_passwd!=ui-&gt;passwdLineEdit-&gt;text())&#123;//密码错误qDebug()&lt;&lt;&quot;passwd not match&quot;;&#125;else&#123;//用户名和密码均正确mainwindow cw(this);this-&gt;hide();cw.show();cw.exec();this-&gt;close(); &#125; &#125; &#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x5F53;&#x6570;&#x636E;&#x5E93;&#x548C;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x90FD;&#x5199;&#x597D;&#x540E;&#xFF0C;&#x65B0;&#x7684;&#x95EE;&#x9898;&#x6765;&#x4E86;&#xFF0C;&#x5728;Qt&#x4E2D;&#x5982;&#x4F55;&#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x5462;&#xFF1F;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x5148;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x628A;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;&#x5B58;&#x5165;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效//查询部分数据(name)QString tempstring=&quot;select * from user where name=&apos;&quot;+name+&quot;&apos;&quot;;//查询的字段为nameqDebug()&lt;&lt;tempstring;if(!sql_query.exec(tempstring))&#123; qDebug()&lt;&lt;sql_query.lastError(); matchFlag=false;&#125;else&#123; while(sql_query.next()) &#123; //将数据存入自己定义的变量中 usr_id = sql_query.value(0).toInt(); usr_passwd = sql_query.value(1).toString(); usr_name = sql_query.value(2).toString(); usr_email = sql_query.value(3).toString(); usr_history = sql_query.value(4).toInt(); &#125; //比如sql_query.value(0).toInt(); //其中的value（0）表示读取的是第几个字段 //toInt（）表示的是读取的数据类型]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
