<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据可视化]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近接手了一个项目，用到了数据可视化，所以今天想给大家简单的说说数据可视化。 首先我们说说为什么要做数据可视化？快视觉是人类获取外界信息最高速，最主要也是最重要渠道。超过50%的人脑功能用于视觉感知，而大脑接收到的信息 90％ 来自视觉，人类利用视觉获取和处理的信息量，远远超出其他途径。人类大脑处理图像的速度比文本快 6 万倍。所谓的“可视化”，就是利用人类视觉化的思考能力，对数据进行可视表达以增强认知的技术。请问上图有多少个V?短时间内，应该很难找到答案吧。我们把上面的图形改造一下，再试一次？现在找到答案就轻而易举了。 有效数据可视化的有效在于，它能够把不易理解的关联维度直观形象地表达出来。最常见的就是地理空间信息，通过地图可以快速有效地得到数据集的宏观理解，所以有这样一句话，“面向公众用户，传播与发布复杂信息最有效途径就是数据可视化”。通过简单的一张图表直观有效的了解了全国各地的空气质量分布 美数据可视化是创造性的设计美学、缜密的数据算法和严谨的工程技术结合的产物，用形象、有趣的形式呈现沉闷繁杂的数据。好的数据可视化作品不仅能挖掘出数据中蕴含的洞察，还能体现出数据之美。数据可视化的表现和创作过程本身就是一门艺术。例如在阿里2017双11购物节 区域经济媒体大屏“中国区域经济闪电图”媒体触控大屏是2017年双11晚会现场的核心焦点之一，大屏上全国上亿买家的订单沿着真实道路涌向卖家，效果震撼。 触控大屏支持用户自助下钻查询数据，极大地增强数据的可读性。当天累计有超过500家中外媒体以此作为现场直播的数据讲解平台，实现了新旧媒体完美融合。 Web 上的数据可视化技术底层技术规范在介绍 Web 上的数据可视化技术前，我们先了解下 Web 图形的底层技术规范： SVG：可缩放矢量图形（Scalable Vector Graphics），是基于可扩展标记语言（标准通用标记语言的子集）的用于描述二维矢量图形的一种图形格式。Canvas 2D：Canvas 通过 JavaScript 来绘制 2D 图形，通过逐像素来进行渲染。Canvas 3D WebGL：WebGL（Web Graphic Library）是一个 JavaScript API，用于在任何兼容的 Web 浏览器中渲染 3D 图形。WebGL 程序由用 JavaScript 编写的控制代码和用 OpenGL 着色语言（GLSL）编写的着色器代码构成，这种语言类似于 C 或 C++，可在 GPU 上执行。 比较流行的基础绘图库，基于 SVG 的有 snap.svg、rapheal.js 等，基于 Canvas 2D 的有 zrender、g 等，基于 WebGL 的有 three.js、SceneJS、PhiloGL 等，这些基础绘图库可以让上层封装更简单容易。 一些相对成熟的解决方案EChartsECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 AntVAntV是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、不限可能的数据可视化最佳实践。 D3相对于echart, highchart等其他图表库算是一个比较底层的可视化工具，简单来讲他不提供任何一种现成的图表，所有的图表都是我们在它的库里挑选合适的方法构建而成。 怎么设计数据可视化选择解决方案在有了成熟的解决方案和相应的库以后代码的问题似乎不是很大，但是可视化的自由程度取决于你对库的选择，像Antv所展示的相关案例就比较简洁大方，而你想要做一些花里胡哨的东西的时候就无从下手只能换库，或者自己手写就很费劲，所以在设计的时候一定要确定自己的这一个Dashboard需要做到什么的一个效果，或简洁，或花哨，从而去把握对解决方案的选择。 布局设计在确定了使用哪一个库之后需要对自己展示的Dashboard有一个大概的设计，先不说配色但是起码的布局得先有大概的一个想法。 指标在布局设计的同时需要关注指标问题，在一个Dashboard中需要展示的东西很多，但是这些东西也是有主次之分的，大概可以先分为主要的两类：主要指标、次要指标。主要次要相对于整个Dashboard而言的，将主要指标放在相对显眼的位置，主要指标很引出一些次要指标，这些次要指标随着主要指标的变化而变化。首先要区分占面积的大小，其次要区分配色！上面这个图是我最近项目做的一个图，因为数据还未完善所以不太好看，在这个图中的主要指标就是地图，总趋势分析和专利对比分析等等都是次要指标，次要指标围绕着主要指标来展示，让人感觉层次清晰。 配色直男癌的配色，你还要我怎样 数据处理做Dashboard最重要的就是数据，而从数据库获取的数据肯定是无法直接投入到代码中去使用的，更何况还有许多奇葩的需求，所以数据的处理更为重要，虽然说后端已经帮你处理了大部分数据，但是因为我们是选择了别人的解决方案所以数据也应该相应的改变，大部分解决方案有了自己的transform方法，可以根据实际情况对数据进行二次处理，说实话我并不太喜欢用这个方法，我喜欢自己去按自己喜欢的方式去处理数据，这样自己理解起来更为方便，换库的时候也不至于令人莫不着头脑。 总结一下我们日常工作总是谈论“用数据说话”，我们肯定不希望我们的目标受众听完就忘了，数据可视化的一个很重要能力就是能够“让受众记住”。无论是美观还是其他什么的，最重要的就是让人能够记住能够理解，这就是去做数据可视化的意义。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀奇古怪的JavaScript]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84JavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript 中 undefined 和 not defined 的区别JavaScript 未声明变量直接使用会抛出异常：var name is not defined，如果没有处理异常，代码就停止运行了。但是，使用typeof undeclared_variable并不会产生异常，会直接返回 undefined。 if (function f(){})与eval()12345var x = 1;if (function y()&#123;&#125;) &#123; x += typeof y;&#125;console.log(x);// 1undefined JavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。下面我们可以把代码改造下，变成其等效代码。123456var x = 1;if (1) &#123; eval(function y()&#123;&#125;); x += typeof y;&#125;console.log(x);// 1undefined eval():该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。如果去除eval()的话就是返回1function 123456var x = 1;if (1) &#123; function y()&#123;&#125;; x += typeof y;&#125;console.log(x); // 1function]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀奇古怪的JavaScript]]></title>
    <url>%2F2019%2F02%2F23%2FnewTab%2F</url>
    <content type="text"><![CDATA[JavaScript 中 undefined 和 not defined 的区别JavaScript 未声明变量直接使用会抛出异常：var name is not defined，如果没有处理异常，代码就停止运行了。但是，使用typeof undeclared_variable并不会产生异常，会直接返回 undefined。 if (function f(){})与eval()12345var x = 1;if (function y()&#123;&#125;) &#123; x += typeof y;&#125;console.log(x);// 1undefined JavaScript中if语句求值其实使用eval函数，eval(function f(){}) 返回 function f(){} 也就是 true。下面我们可以把代码改造下，变成其等效代码。123456var x = 1;if (1) &#123; eval(function y()&#123;&#125;); x += typeof y;&#125;console.log(x);// 1undefined eval():该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。如果去除eval()的话就是返回1function 123456var x = 1;if (1) &#123; function y()&#123;&#125;; x += typeof y;&#125;console.log(x); // 1function]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计大赛心得]]></title>
    <url>%2F2018%2F11%2F27%2Fdevelopment-website%2F</url>
    <content type="text"><![CDATA[网页设计大赛心得说在前面的话 本次比赛从十月十一号正式在Gitlab上搭建，做的题材就是我们院科协的1.0版本，临时参考了各种酷炫网站的各种特效并打算将其组合起来，但是发现实际效果好像不太行，所以决定走简约风格，而这个呢就是参考某一个网站具体网址我也忘了。啰嗦了这么多就开始进入正题吧。 技术选型 首先说说技术选型，其实我也考虑了vue+webpack+vuex这一套，但是因为这个比赛比较简单也不需要做SPA从短期来看用这一套就感觉不太好，所以呢我就考虑了jQuery+Bootstrap来一揽子搞定它，后来不知怎么的好像一开始布局的时候哪里抽了不知道，忘记使用bootstrap了，所以就决定玩一把大的，自己处理布局问题不再使用栅格系统，随之而来的问题就是移动端什么的都得自己解决了，这很是令人头秃，但是却也让我们放开了手脚，直接开始浪！所以我们唯一使用的库就只有jQuery了！ 开发中的一些问题 这次因为比赛原因仓库项目并不能公开，所以我们把它放在了Gitlab上，首先说说整个结构 一目了然了吧，我们这个项目是十分简单的（虽然后期不利于维护，但是那已经不是我们的锅了，只能给接锅的人说抱歉了），images里面不仅存了图片还有一些其他的多媒体资源，lib放的是一些外部的库。 其实吧，我jio得整个项目都简单的一批，虽然简单但是还是听我们叨叨（吐槽）一会儿吧，首先就是布局上踩了无数的坑以及在其他终端的适配出现了许多魔性的bug，比如什么fixed以后会被背景盖住，懒加载没有加载出来时高度消失了之类的玄学问题，让我对CSS又有了新的认识，我再也不敢小觑它了，太可怕了。当整个页面布局开始复杂的时候，因为没有用bootstrap所以想要调整某一块的布局时不得不往上再调整几个父容器，不由的感叹我们的头真铁啊！在js方面的话，因为是合作开发所以有些地方就比较乱，这也是没有套用框架的一个不好的地方吧，我们不能实现模块化组件化开发，两个人同时写js势必会相互影响，所以后期基本都是在互相调bug，以及互相看不懂代码等等各种奇葩问题，技术能力没有长进多少，甩锅能力堪称一流了。最后还想吐槽一下Team部分的介绍部分，感觉自己都被掏空了，是我太菜还是我菜我已经分不清了，在判断页面是否显示介绍文字这一块掉了我不少头发，因为在HTML中每一个item嵌套了太多个盒子，在查询判断的时候不考虑时间的话之间用循环慢慢找就好，但是需要考虑到用户体验提高速度就不得不先获取点击item的id再向上查找对应的介绍部分，在所借鉴的例子中采用的是每一个item对应一个节点，而我是只有一个节点，根据不同的item的id查询到相应的介绍文字并将节点里的文字图片替换，感觉多此一举了。反而一开始认为很难的canvas动画部分被很轻易的就搞定了，真的是太XX了。最后小声bb几句（真正的懒加载，监听视窗到达相应高度出现内容，这是传统的懒加载，实现原理就是改变src来解决的，实际的DOM是已经存在的，而我们加的这个戏就很棒了，搞一个真正的懒加载？？？我们直接移除节点，到了指定位置再加载节点，天呐，现在回想起来我都在想我们是不是疯了，lazyload不好用么，为什么要这么折腾自己呢） 写代码的时候大概就是那么多问题了，我甚至觉得写了这么一个项目到底值不值得我写一篇心得来总结它，因为它太简单了，但是因为我们的各种加戏变得不简单了。 开发周期 接下来是时间的安排，时间上还是比较充裕的（一开始），后来发现剩下两周居然是实训周，所以后期就比较赶，大部分功能内容都是在那一段时间赶出来的，想想我们，刚刚磨完锤子，又要去调布局做动画，我哭了，你呢？！ 最后再说几句 好了，这个项目大概就是这样了，上一年大一的时候自己心心念念想做的东西到现在真正的做出来了反而没有了当初那一份说不出来的感觉了最后上地址http://njupt-sacc.com/ 之后会再写一些遇到的问题以及解决方案]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>网页设计大赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F10%2F29%2FES6%2F</url>
    <content type="text"><![CDATA[ES6 各种新语法 入门了解 石川blue讲解 视频地址 b站：深入解读ES6系列 看视频整理要点笔记: hello-es6 1.ES6怎么来的 2.ES6兼容性 3.变量 let 和 常量 const 4.函数-箭头函数 5.函数-参数 6.解构赋值 7.数组 8.字符串 9.面向对象-基础 10.面向对象应用 11.json 12.Promise 13.generator-认识生成器函数 14.generator-yield是啥 15.generator-实例 16.ES7 预览 1.ES6怎么来的 ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES 历史版本 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布 2.ES6兼容性 ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换 在线转换 或者提前编译 Babel 中文网 Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持 3.变量 let 和 常量 const var 的问题 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { } let 和 const 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改 块级作用域举例 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.onload= function () &#123; /* var aBtn = document.getElementsByTagName('input') for (var i=0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;*/ var aBtn = document.getElementsByTagName('input') for (let i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125; /* var aBtn = document.getElementsByTagName('input') for (var i = 0; i &lt; aBtn.length; i++) &#123; // 封装到函数里，限制作用域 (function (i) &#123; aBtn[i].onclick = function () &#123; alert(i) &#125; &#125;)(i) &#125;*/ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="按钮1"&gt; &lt;input type="button" value="按钮2"&gt; &lt;input type="button" value="按钮3"&gt;&lt;/body&gt;&lt;/html&gt; 4.函数-箭头函数 箭头函数，就是函数的简写 如果只有一个参数，() 可以省 如果只有一个return，{}可以省 12345678// 普通函数function name() &#123;&#125;// 箭头函数，去掉 function， 加上 =&gt;() =&gt; &#123;&#125; 12345678910111213141516171819let show1 = function () &#123; console.log('abc')&#125;let show2 = () =&gt; &#123; console.log('abc')&#125;show1() // 调用函数show2()let show4 = function (a) &#123; return a*2&#125;let show5 = a =&gt; a * 2 //简洁，类似python lambda 函数console.log(show4(10))console.log(show5(10)) 5.函数-参数 参数扩展／展开 ...args 收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样 默认参数 12345678910111213141516function show(a, b, ...args) &#123; console.log(a) console.log(b) console.log(args)&#125;console.log(show(1, 2, 3, 4, 5))let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]let arr3 = [...arr1, ...arr2]console.log(arr3)function show2(a, b=5, c=8) &#123; console.log(a, b, c)&#125;show2(88, 12) 6.解构赋值12345678let [a, b, c] = [1, 2, 3]console.log(a, b, c)let &#123;x, y, z&#125; = &#123;x: 1, y: 2, z: 3&#125;console.log(x, y, z)let [json, arr, num, str] = [&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, 'str']console.log(json, arr, num, str) 解构赋值 左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里 7.数组 新增4个方法 map 映射 一个对一个 12345678910111213141516let arr = [12, 5, 8]let result = arr.map(function (item) &#123; return item*2&#125;)let result2 = arr.map(item=&gt;item*2) // 简写console.log(result)console.log(result2)let score = [18, 86, 88, 24]let result3 = score.map(item =&gt; item &gt;= 60 ? '及格' : '不及格')console.log(result3)// 结果[ 24, 10, 16 ][ 24, 10, 16 ][ '不及格', '及格', '及格', '不及格' ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 1234567891011121314151617var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; //tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item&#125;)console.log(result)var arr = [1, 3, 5, 7]var result = arr.reduce(function (tmp, item, index) &#123; if (index != arr.length - 1) &#123; // 不是最后一次 return tmp + item &#125; else &#123; return (tmp + item)/arr.length &#125;&#125;)console.log(result) // 平均值 filter 过滤器 保留为true的 123456789101112var arr = [12, 4, 8, 9]var result = arr.filter(item =&gt; (item % 3 === 0) ? true : false)console.log(result)var result = arr.filter(item =&gt; item % 3 === 0)console.log(result)var arr = [ &#123; title: '苹果', price: 10 &#125;, &#123; title: '西瓜', price: 20 &#125;,]var result = arr.filter(json =&gt; json.price &gt;= 20)console.log(result) forEach 循环迭代 123var arr = [12, 4, 8, 9]var result = arr.forEach(item =&gt; console.log(item))var result = arr.forEach((item, index)=&gt;console.log(item, index)) 8.字符串 多了两个新方法 startsWith endsWith 1234var url = 'http://qq.com'console.log(url.startsWith('http'))console.log(url.endsWith('com'))// 都是 true 字符串模版 使用反引号，${变量} 可以折行 1234567891011121314let a = 12let str1 = `asdf$&#123;a&#125;`console.log(str1)let title = '标题'let content = '内容'let str = `&lt;div&gt;&lt;h1&gt;$&#123;title&#125;&lt;/h1&gt;&lt;p&gt;$&#123;content&#125;&lt;/p&gt;`console.log(str)&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;内容&lt;/p&gt; 9.面向对象-基础 原来写法 类和构造函数一样 属性和方法分开写的 123456789101112131415161718192021222324252627282930// 老版本function User(name, pass) &#123; this.name = name this.pass = pass&#125;User.prototype.showName = function () &#123; console.log(this.name)&#125;User.prototype.showPass = function () &#123; console.log(this.pass)&#125;var u1 = new User('able', '1233')u1.showName()u1.showPass()// 老版本继承function VipUser(name, pass, level) &#123; User.call(this, name, pass) this.level = level&#125;VipUser.prototype = new User()VipUser.prototype.constructor = VipUserVipUser.prototype.showLevel = function () &#123; console.log(this.level)&#125;var v1 = new VipUser('blue', '1234', 3)v1.showName()v1.showLevel() 新版面向对象 有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类 12345678910111213141516171819202122232425262728293031class User &#123; constructor(name, pass) &#123; this.name = name this.pass = pass &#125; showName() &#123; console.log(this.name) &#125; showPass() &#123; console.log(this.pass) &#125;&#125;var u1 = new User('able2', '111')u1.showName()u1.showPass()// 新版本继承class VipUser extends User &#123; constructor(name, pass, level) &#123; super(name, pass) this.level = level &#125; showLevel()&#123; console.log(this.level) &#125;&#125;v1 = new VipUser('blue', '123', 3)v1.showLevel() 10.面向对象应用 React 用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js 11.json JSON 格式 JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来 JSON 对象 JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。 123456789101112var json = &#123;a: 12, b: 5&#125;var str = 'hi,' + JSON.stringify(json)var url = 'http://www.xx.com/' + encodeURIComponent(JSON.stringify(json))console.log(str)console.log(url)var str = '&#123;"a": 12, "b": 4, "c": "abc"&#125;'var json = JSON.parse(str)console.log(json)hi,&#123;"a":12,"b":5&#125;http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D&#123; a: 12, b: 4, c: 'abc' &#125; 对象（object） 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for…in循环用来遍历一个对象的全部属性 对象 简写 key-value 一样时可以简写 里面函数可以简写, 去掉 123456789var a = 12, b = 5console.log(&#123;a:a, b:b&#125;)console.log(&#123;a, b&#125;)console.log(&#123;a, b, c:"c"&#125;)console.log(&#123; a, b, show()&#123; console.log('a') &#125;&#125;)&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5 &#125;&#123; a: 12, b: 5, c: 'c' &#125;&#123; a: 12, b: 5, show: [Function: show] &#125; 12.Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise 对象 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 Promise 也是一个构造函数 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数 12345function f1(resolve, reject) &#123; // 异步代码...&#125;var p1 = new Promise(f1);p1.then(f2); // f1的异步操作执行完成，就会执行f2。 Promise 使得异步流程可以写成同步流程 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3]&#125;); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 13.generator-认识生成器函数 generator 生成器函数 普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停 123456789101112131415function show() &#123; console.log('a') console.log('b')&#125;show() // 普通函数function *show2() &#123; console.log('1') yield console.log('2')&#125;let genObj = show2()genObj.next() // 1genObj.next() // 2genObj.next() // 最后了，没有结果 14.generator-yield是啥 yield 既可传参，又可以返回 第一个next()传参无效，只用来启动 如果函数前漏掉 * 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用 1234567891011121314151617181920212223242526function * show() &#123; console.log('1') var a = yield console.log('2') console.log(a)&#125;// yield 传参var gen = show()gen.next() // 1gen.next() // 2 和 undefined 因为没有传参，yield没有返回值var gen = show()gen.next(10) // 1 第一次执行到yield，但没有执行赋值gen.next(20) // 2 和 20function* show2() &#123; console.log('1') yield 10 console.log('2')&#125;// yield 返回var gen = show2()var res1 = gen.next()console.log(res1) // &#123; value: 10, done: false &#125;var res2 = gen.next()console.log(res2)// &#123; value: undefined, done: true &#125; 最后的value需要return返回 15.generator-实例 Promise 适合一次读一组 generator 适合逻辑性的 12345678910// 带逻辑-generatorrunner(function * () &#123; let userData = yield $.ajax(&#123;url: 'getUserData'&#125;) if (userData.type == 'VIP') &#123; let items = yield $.ajax(&#123;url: 'getVIPItems'&#125;) &#125; else &#123; let items = yield $.ajax(&#123;url: 'getItems'&#125;) &#125;&#125;) 12345// yield 实例，用同步方式写异步server.use(function * () &#123; let data = yield db.query(`select * from user_table`) this.body = data&#125;) 16.ES7 预览 数组 arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for … in 遍历数组 下标 key for … of 遍历数组 值 value, 不能用于json 123456789101112131415161718192021let arr = ['a', 'b', 'c']console.log(arr.includes(1))for (let i in arr) &#123; console.log(i) // 循环的时下标 key&#125;for (let i of arr) &#123; console.log(i) // 循环的是值 value&#125;for (let i of arr.keys()) &#123; console.log('&gt;'+i)&#125;for (let [key, value] of arr.entries()) &#123; console.log('&gt;' + key + value)&#125;let json = &#123; a: 12, b: 5, c: 7 &#125;for (let i in json) &#123; console.log(i)&#125; 字符串 padStart()/padEnd() 指定宽度，不够就补空格或指定字符 1234console.log('=' + 'abcd'.padStart(6, '0') + '=')console.log('=' + 'abcd'.padEnd(6, '0') + '=')=00abcd==abcd00= 容忍度 [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以 async await 和 generator yield 类似 generator 不可以写成箭头函数， async 可以 12345async function show() &#123; console.log(1) await console.log(2)&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antv]]></title>
    <url>%2F2018%2F10%2F19%2FAntv%2F</url>
    <content type="text"><![CDATA[Antv踩的一些坑因为项目需要做一些数据可视化的东西，一开始考察了几个库，比如：echart、D3、antv，因为后面可能需要做一些类似地图的图表而echart这个库做不了，还改了一次库，D3的话上手难度比较高。具体的一些设置我就不说了，官方文档写的相当详细了。创建一个图表可以说是相当的简单，你只需要123456var chart=new G2.chart(&#123; container: &apos;id&apos;,&#125;);chart.source(data);chart.interval().postion(&apos;x*y&apos;).size(5);chart.render(); 可以看到只需要指定一个id和一个数据来源就可以建立一张简单的表了，这个有一个坑就是数据的问题，x*y对应data中的字段，eg:1234567891011var data=[ &#123;time:&apos;2008&apos;,num:30,percentage:0&#125;, &#123;time:&apos;2009&apos;,num:40,percentage:0.33&#125;, &#123;time:&apos;2010&apos;,num:44,percentage:0.1&#125;, &#123;time:&apos;2011&apos;,num:38,percentage:-0.16&#125;, &#123;time:&apos;2012&apos;,num:26,percentage:-0.32&#125;, &#123;time:&apos;2013&apos;,num:33,percentage:0.27&#125;, &#123;time:&apos;2014&apos;,num:44,percentage:0.33&#125;, &#123;time:&apos;2015&apos;,num:37,percentage:-0.16&#125;, &#123;time:&apos;2016&apos;,num:47,percentage:0.27&#125;, &#123;time:&apos;2017&apos;,num:55,percentage:0.15&#125;]; 如果设置postion(‘time*num’)就对应设置成time字段的数据为x轴，num数据为y轴。这里又引出了一个新的坑，比如如果你的字段是英文的但是你在x轴显示的时候你想展示成英文的你就需要为你的字段设置一个新的别名来改变原有的英文字段，eg:12345678chart.scale(&#123; &apos;name&apos;: &#123; alias: &apos;IPCs&apos; // 设置属性的别名 &#125;, &apos;value&apos;: &#123; alias: &apos;数量&apos; &#125; &#125;); 这样就可以将name的别名改为IPCs在网页显示的时候显示的也是IPCs，下面的value同理。 之后会讲一些回调函数等着再更新]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 搭博客踩坑大全]]></title>
    <url>%2F2018%2F10%2F19%2Fhexo-%E6%90%AD%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Git+hexo 搭博客 作为一个老学长帮新生搭博客，在这过程中遇到了许多坑，什么大小写问题全角标点不注意空格看不到之类的已经数不胜数了，下面有几点要注意！！！！！！ 仔细看好大小写注意全角和半角的切换配置里冒号后面都有空格安装Git bash，安装Nodejs，注册Github安装Git bash和Nodejs直接在官网安装就好了，然后到github上注册账号 安装hexo安装hexo的话，打开cmd输入npm i -g hexo,如果加载速度过慢或者不动的话建议换一个网络试试 生成ssh key生成ssh key打开你的Git bash，输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot;,接下来连续三个回车出现一个个人ssh key，然后再输入cd ~/.ssh之后输入cat id_rsa.pub会出现一串以ssh-rsa开头的一段公钥。复制打开你的github在设置中找到SSH and GPG keys建立一个新的SSH keys。 配置博客前面的做好之后打开你之前建立的博客文件夹找到一个名为_config.yml（冒号之后都是有一个半角空格）1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到Git bash进入blog，执行123hexo cleanhexo ghexo s 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。打开浏览器http://localhost:4000就可以看到你的博客了 部署项目先安装：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）安装好后执行123hexo cleanhexo generatehexo deploy 在浏览器中输入http://你的用户名.github.io就可以看到你的个人博客啦，是不是很兴奋！]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2018%2F08%2F11%2FReact%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[render外层嵌套的divrander函数return只能返回一个大的JSX，如果出现两个就需要在外面套一个&lt;div&gt;&lt;/div&gt;但是多出来的一个不必要的div会给我们增加许多的麻烦所以就可以用&lt;React.fragment&gt;&lt;/React.fragment&gt;来取代&lt;div&gt;&lt;/div&gt;。 关于key值的warningWarning: Each child in an array or iterator should have a unique “key” prop.这个Warning代表缺少key值，补充一下key值的是干嘛的： 当我们组件状态更新后，会重新渲染组件，渲染组件的时候会一个个去根据key值的情况去渲染：A. 渲染前的key值存在，则去寻找这个key值对应的组件： &nbsp;&nbsp;a.组件数据不变，则不重新渲染这个组件； &nbsp;&nbsp;b.若组件数据改变，则渲染改变的这一部分数据；B.渲染前的key值不存在，则会销毁这个key值对应的组件：C.出现新的key值，则渲染一个新的key值对应的组件； 父组件与子组件的通信将网页拆分成多个组件之后还可以将大的组件继续拆分，所以就出现了子组件，但是父组件与子组件是如何通信的呢？父组件向子组件传值，这个比较容易理解，例如&lt;TodoItem handDelete={this.handDelete.bind(this)} key={index} index={index} content={item}/&gt;中的content就是向子组件传递了一个item值，在子组件接手数据的时候则是this.props.content等于父组件中的item值。子组件如何与父组件通信总的来说就是通过函数传递，父组件那边写好了处理子组件数据的函数并传给子组件，子组件调用函数并传入数据，父组件就可以接收数据并存储。 React里面写函数有特定的规则React里面写函数有特定的规则，例如onClick={this.handleBtnClick.bind(this)}与普通JavaScript不同的是大小写和花括号的区别，调用css的区别也差不多用的是className={style}而不是class=“style”。总的来说再我看来，大概就是有这么几种情况，当代码块中间有-之类的，比如font-size:48px就需要改写成驼峰写法fontSize:48px，还有就是与语法冲突了比如css中的class和JavaScript中的class重名了所以才需要用className来表示类名。 JSX注释123456在JSx中注释与在JavaScript中略有不同，之前说过在JSX想写js的话需要加一个&#123; &#125;写注释的时候同理&#123;/*这是注释*/&#125;单行注释比较麻烦&#123;//这是注释&#125; 输入不转译&lt;li&gt;dangerrouslySetInnerHTML={{__html: item}}&lt;/li&gt; 利用lable聚焦123&lt;lable&gt;输入聚焦&lt;lable htmlFor=&quot;a&quot;&gt;输入内容&lt;/lable&gt;&lt;input id=&quot;a&quot;&gt; 关于Registerserviceworkerimport Registerserviceworker from ‘Registerserviceworker’；PWA progressive web application,它在有https协议的服务器上缓存可以离线运行。 科普PWAPWA全称Progressive Web App，直译是渐进式WEB应用，是 Google 在 2015 年提出，2016年6月才推广的项目。是结合了一系列现代Web技术的组合。在网页应用中实现和原生应用相近的用户体验。所谓的P（Progressive）这里有两层含义，一方面是渐进增强，让WEB APP的体验和功能能够用渐进增强的方式来更接近原生APP的体验及功能。另一方面是指下一代WEB技术。PWA并非描写叙述一个技术。而是一些技术的合集。 propTypes与defaultPropspropTypes顾名思义prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型。eg：1234567891011121314151617yourComponent.propTypes = &#123; 属性1：属性1的变量类型， 属性2：属性2的变量类型 //...&#125;XX.propTypes = &#123; optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型 number:PropTypes.oneOfType( [PropTypes.string,PropTypes.number] )//规定多个检测通过的数据类型&#125; defaultPropsReact组件的默认状态（defaultProps），给你的数据设定默认数据。eg：123456789101112131415161718192021222324class XX extends React.Component &#123; constructor(props)&#123; super(props); this.state=&#123; name:props.name &#125;; &#125;&#125;XX.defaultProps=&#123; name:&apos;default name&apos;&#125;;orconst XXX=(props)=&gt;&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; );&#125;XXX.defaultProps=&#123; name:&apos;default name&apos;&#125;; state props renderprops设置 props 的方式1）可以在组件挂载时设置props：123456var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);React.render(&lt;HelloWorld name=&quot;Sam&quot; /&gt;, document.body); 2）也可以通过调用组件实例的setProps()方法来设置props（在ES6中将被禁用，这个方法不支持ES6类组件React.Component扩展。）1234567var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);var instance = React.render(&lt;HelloWorld/&gt;, document.body);instance.setProps(&#123;name: &apos;Tim&apos;&#125;); prop 支持的数据类型我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop：&lt;App id=&quot;sample&quot; borderWidth={2} onClick={onButtonClick}/&gt;在上面的例子中，创建了名为 App 的组件实例，使用了名字分别为id、borderWidth、onClick和style的 prop，看起来，React组件的 prop 很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌的JavaScript，也依然是字符串形式表示代码。React组件的 prop 所能支持的类型则丰富得多，可以是任何一种JavaScript语言支持的数据类型。比如在上面的App中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当 prop 的类型不是字符串类型时，在JSX中必须用花括号{}把 prop 值包住，所以style的值有两层花括号，外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。当外部世界要传递一些数据给React组件，一个最直接的方式就是通过 prop；同样，React组件要反馈数据给外部世界，也可以用 prop，因为 prop 的类型不限于纯数据，也可以是函数，函数类型的 prop 等于让父组件交给了子组件一个回调函数，子组件在恰当的实际调用函数类型的 prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。不要修改props这样是反模式，因为 React 不能帮你检查属性类型（propTypes）。这样即使你的属性类型有错误也不能得到清晰的错误提示。Props 应该被当作禁止修改的。修改 props 对象可能会导致预料之外的结果，所以最好不要去修改 props 对象。关于super(props)如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过 super 调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过 this.props 访问到父组件传递过来的 props 值。 关于 statethis.state 与 this.setState在代码中，通过 this.state 可以读取到组件的当前 state。值得注意的是，我们改变组件 state 必须要使用 this.setState 函数，而不能直接去修改 this.state 。直接修改 this.state 的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了 state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应 this.state 值的变化；而 this.setState() 函数所做的事情，首先是改变 this.state 的值，然后驱动组件经历更新过程，这样才有机会让 this.state 里新的值出现在界面上。构造函数 constructor初始化 state，因为组件生命周期中任何函数都可能要访问 state，那么整个生命周期中第一个被调用的构造函数自然是初始化 state 最理想的地方；绑定成员函数的 this 环境；在ES6语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的。而在构造函数中，this 就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前实例。 render通常一个组件要发挥作用，总是要渲染一些东西，render 函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。（render函数并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。）需要注意，render 函数应该是一个纯函数，完全根据 this.state 和this.props 来决定返回的结果，而且不要产生任何副作用。在 render 函数中去调用this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。父组件的render运行时子组件的render自动被重新运行一次 虚拟DOM1、state 数据2、JSX 模板3、生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）[&#39;idv&#39;,{id:&#39;abc&#39;},[&#39;span&#39;,{},&#39;hello world&#39;]]4、用虚拟结构的DOM生成真实的DOM&lt;div id=&#39;a&#39;&gt;&lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;5、state发生变化6、生成新的虚拟DOM7、比较原始虚拟DOM和新的虚拟DOM的区别，找到区别的内容 Diff，当第一层不同的时候删除以下所有DOM节点，用新的替换， 同层比较，算法简单，与key值做关联。index不作为key值的理由：删除一个节点所有index发生变化与旧的虚拟DOM不相同无法建立关联损耗性能 8、直接操作DOM替换其中不同的地方优点：1、性能提升了2、它使得跨端应用得以实现，React Native。3、JSX -&gt; Js对象(React.createElement) -&gt; 真实的DOM（不用去繁琐的使用React.createElement(&#39;div&#39;,{},&#39;item&#39;)）//React.createElement(&#39;div&#39;,{},&#39;item&#39;)是更为底层的语法 生命周期函数生命周期函数指在某一个时刻组件会自动调用执行的函数，render就是一个生命周期函数。组件经历过的几个过程：初始化定义state接收props挂载 componentWillMount（组件即将被挂载到页面的时候执行） render componentDidMount（组件被挂载之后执行） 组件更新 当数据（props、state）发生变化时执行生命周期函数，shouldComponentUpdata(组件即将被变更)产生布尔返回值，true是需要改变组件，false不需要更新。 componentWillUpdata（组件被更新之前shouldComponentUpdata返回true执行）。 render重新渲染。 componentDidUpdata（组件更新完成之后执行）。 componentWillReceiveProps（没有props的情况下不会被执行，顶层组件没有接收所以不会调用。当一个组件从父组接收参数，只要父组件的render函数被重新执行了，子组件的这个函数就会被执行） 去除挂载 componentWillUnmount（当这个组件即将被从页面种剔除的时候执行的函数） 所有生命周期函数可以不存在，render函数必须存在，因为之前继承了component里面就已经有了 DOM节点操作与插件结合我们可以在任何网页应用中使用 React。不仅可以把 React 添加到其他应用里，而且只要稍作改动，我们也可以把其他应用添加到 React 项目里。将 React 与 jQuery 结合使用。当然，类似的思路同样可以应用与其他场景。对于 React 之外的 DOM 节点操作，React 是不会去处理的，因为 React 内部有自己的渲染逻辑。当相同的 DOM 节点被外部的代码改变时，React 就会很迷茫，并不知道发生了什么。在这里，我们给 DOM 的根节点元素加了一个 ref。在 componentDidMount 中，我们会调用这个 ref，并把它传给 jQuery 插件。123456789101112131415161718class SomePlugin extends React.Component &#123; componentDidMount() &#123; this.$el = this.el;//获取到DOM节点，可以对DOM进行操作 this.$el.&#123; //对DOM进行操作 Do something innerHTML append &#125; &#125; componentWillUnmount() &#123; this.$el.somePlugin(&apos;destroy&apos;);//卸载事件监听器 &#125; render() &#123; return &lt;div ref=&#123;el =&gt; this.el = el&#125; /&gt;; &#125;&#125; 为了防止 React 在 DOM 加载后修改节点，我们先要在 render() 中返回一个空的 &lt;div /&gt;。这个空的&lt;div /&gt;既没有属性也没有子元素，这样一来，React 就不会更新它了。那么，我们封装的 jQuery 插件就可以随意地更新这个节点。其实这样做不只使用与jQuery ，同样适用于原生的JavaScript的DOM操作。]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React快速入门]]></title>
    <url>%2F2018%2F08%2F11%2FReact01%2F</url>
    <content type="text"><![CDATA[开发环境搭建首先搭建node环境（后面细讲），然后到react官网看官方文档里的Create React App里的两端代码，我是在Windows下所以打开cmd输入npx create-react-app my-app之后cd到安装目录下执行npm start就自动构建成了新的项目，至于webpack啥的还没开始学就先不讲了。 精简代码在npm start执行后自动在浏览器打开了一个页面，找到你之前创建了的文件夹，src文件里存放着代码，index.js是这个项目的入口文件，registerServiceWorker是pwa（离线页面），现在用不到可以先精简了，还有import ./index。css这个是样式文件也可以精简了，最后留下三句话就够了import React, {Component,Fragment} from &#39;react&#39;;import TodoItem from &#39;./TodoItem&#39;; 什么是组件React是基于组件的框架，组件就是将网页局部化，将一个大的网页分成大的几块这就是组件，这些组件再拆分成小组件。打开index.js组件就是从 import A from &quot;./A&quot;引入而ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&#39;root&#39;));则是在一个id为root的地方进行渲染 JSXJavaScript与xml，在代码中可以轻松的使用html标签而不会报错，而想使用JavaScript的时候加一个{}就好了，但是只可以是表达式而不是语句。eg：1234567891011121314151617class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); this.handleItemClick=this.handleItemClick.bind(this); &#125; handleItemClick()&#123; this.props.handDelete(this.props.index); &#125; render()&#123; const &#123;content&#125;=this.props; return ( &lt;div&gt; &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;content&#125;&lt;/li&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About css选择器]]></title>
    <url>%2F2018%2F08%2F02%2FAbout-css%2F</url>
    <content type="text"><![CDATA[写在前面的话在我看来css是我在编程过程中最头疼的几个问题之一，首先是定位问题，对css元素、选择器不熟悉的话肯定要出问题，其次就是浮动问题，最后就是响应式布局，这里我主要就是记录css，其他的后面再单独记录。 css的选择器css的选择器大致可以分为： 元素选择器元素选择器，最基本的选择器，如果设置 HTML 的样式，选择器通常将是某个 HTML 元素，比如 p、h1、em、a，甚至可以是 html 本身。eg:123html &#123;color:black;&#125;h1 &#123;color:blue;&#125;h2 &#123;color:silver;&#125; 类选择器类选择器，类选择器允许以一种独立于文档元素的方式来指定样式。在使用类选择器之前，需要修改具体的文档标记，以便类选择器正常工作。为了将类选择器的样式与元素关联，必须将 class 指定为一个适当的值。通过class来获取事先指定好的样式。eg:1&lt;h1 class=&quot;important&quot;&gt;&lt;/css&gt; 1.important &#123;color:red;&#125; ID选择器ID选择器，ID 选择器类似于类选择器，不过也有一些重要差别，ID 选择器前面有一个#号，ID 选择器不引用 class 属性的值，毫无疑问，它要引用 id 属性中的值。与类不同，在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次。不同于类选择器，ID 选择器不能结合使用，因为 ID 属性不允许有以空格分隔的词列表。eg:1&lt;p id=&quot;intro&quot;&gt;hello world.&lt;/p&gt; 1*#intro &#123;font-weight:bold;&#125; 属性选择器属性选择器，CSS 2 引入了属性选择器。属性选择器可以根据元素的属性及属性值来选择元素，这个东西我并不经常用，因为我感觉比较玄，一般都是用上面几种。这个就大致讲一下用法，大概就是指定一个标签，然后这种标签带有特定属性的都被选择。eg:1234a[href][title] &#123;color:red;&#125;//可以只对有 href 属性的锚（a 元素）应用样式img[alt] &#123;border: 5px solid red;&#125;//可以对所有带有 alt 属性的图像应用样式，从而突出显示这些有效的图像 后代选择器后代选择器，根据上下文选择元素，我们可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。后代选择器的功能极其强大。有了它，可以使 HTML 中不可能实现的任务成为可能。假设有一个文档，其中有一个边栏，还有一个主区。边栏的背景为蓝色，主区的背景为白色，这两个区都包含链接列表。不能把所有链接都设置为蓝色，因为这样一来边栏中的蓝色链接都无法看到。eg：12345css部分div.sidebar &#123;background:blue;&#125;div.maincontent &#123;background:white;&#125;div.sidebar a:link &#123;color:white;&#125;div.maincontent a:link &#123;color:blue;&#125; 12345678910111213141516171819html部分&lt;ul&gt; &lt;li&gt;List item 1 &lt;ol&gt; &lt;li&gt;List item 1-1&lt;/li&gt; &lt;li&gt;List item 1-2&lt;/li&gt; &lt;li&gt;List item 1-3 &lt;ol&gt; &lt;li&gt;List item 1-3-1&lt;/li&gt; &lt;li&gt;List item &lt;em&gt;1-3-2&lt;/em&gt;&lt;/li&gt; &lt;li&gt;List item 1-3-3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 1-4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt; 子元素选择器子元素选择器，这个选择器与后代选择器类似，不过区别于后代选择器它只能选择某个元素的子元素。eg:1h1 &gt; strong &#123;color:red;&#125; 1&lt;h1&gt; hello &lt;strong&gt;world&lt;/strong&gt;&lt;/h1&gt; 相邻兄弟选择器相邻兄弟选择器,子元素选择器、后代选择器、相邻兄弟选择器这三个选择器效果都差不多，只不过一个选择器比一个选择器缩小了范围而已，后代选择的是所有后代，子元素是某个元素的所有子元素，相邻兄弟选择器是选择下一个或者上一个。eg:12h1 + p &#123;margin-top:50px;&#125;//选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素 就写到这里吧，css的选择器是比较关键的，其他的过几天再总结，就这样~]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About html]]></title>
    <url>%2F2018%2F08%2F02%2Fabout-html%2F</url>
    <content type="text"><![CDATA[写在前面的一些话入门前端也有不短的一段时间了自己前前后后也看了许多教程和视频，也算是入了前端的坑了吧，感觉前端学习的东西太杂了怕自己捋不清所以写下笔记记录一下。 Html DOM html在我看来如果不算H5的话它就好比一幢楼房的钢筋部分，html的语法并不难甚至可以说是很简单，标签也越来越语义化，但是学习html是为了让你对DOM树有一种感觉，就好像在开始建造房屋时你得想好需要建多高每层要搭建一些什么东西。在一些小页面可能无法体现，但是到了大型网站这就变得至关重要了。 这其实也是一个节点图，文档中的所有内容、所以标签都可以视为一个节点，这样就可以利用节点做许多操作，例如： ① 查询某个元素 ② 查询某个元素的祖先、兄弟以及后代元素 ③ 获取、修改元素的属性 ④ 获取、修改元素的内容 ⑤ 创建、插入和删除元素 关于这些操作涉及到了JavaScript所以这里就不细讲了，总之学习html在掌握语法的同时也要构建一种DOM树的思想。 标签的用法总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;a&gt; 定义锚。&lt;abbr&gt; 定义缩写。&lt;acronym&gt; 定义只取首字母的缩写。&lt;address&gt; 定义文档作者或拥有者的联系信息。&lt;applet&gt; 不赞成使用。定义嵌入的 applet。&lt;area&gt; 定义图像映射内部的区域。&lt;article&gt; 定义文章。&lt;aside&gt; 定义页面内容之外的内容。&lt;audio&gt; 定义声音内容。&lt;b&gt; 定义粗体字。&lt;base&gt; 定义页面中所有链接的默认地址或默认目标。&lt;basefont&gt; 不赞成使用。定义页面中文本的默认字体、颜色或尺寸。&lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置。&lt;bdo&gt; 定义文字方向。&lt;big&gt; 定义大号文本。&lt;blockquote&gt; 定义长的引用。&lt;body&gt; 定义文档的主体。&lt;br&gt; 定义简单的折行。&lt;button&gt; 定义按钮 (push button)。&lt;canvas&gt; 定义图形。&lt;caption&gt; 定义表格标题。&lt;center&gt; 不赞成使用。定义居中文本。&lt;cite&gt; 定义引用(citation)。&lt;code&gt; 定义计算机代码文本。&lt;col&gt; 定义表格中一个或多个列的属性值。&lt;colgroup&gt; 定义表格中供格式化的列组。&lt;command&gt; 定义命令按钮。&lt;datalist&gt; 定义下拉列表。&lt;dd&gt; 定义定义列表中项目的描述。&lt;del&gt; 定义被删除文本。&lt;details&gt; 定义元素的细节。&lt;dir&gt; 不赞成使用。定义目录列表。&lt;div&gt; 定义文档中的节。&lt;dfn&gt; 定义定义项目。&lt;dialog&gt; 定义对话框或窗口。&lt;dl&gt; 定义定义列表。&lt;dt&gt; 定义定义列表中的项目。&lt;em&gt; 定义强调文本。&lt;embed&gt; 定义外部交互内容或插件。&lt;fieldset&gt; 定义围绕表单中元素的边框。&lt;figcaption&gt; 定义 figure 元素的标题。&lt;figure&gt; 定义媒介内容的分组，以及它们的标题。&lt;font&gt; 不赞成使用。定义文字的字体、尺寸和颜色。&lt;footer&gt; 定义 section 或 page 的页脚。&lt;form&gt; 定义供用户输入的 HTML 表单。&lt;frame&gt; 定义框架集的窗口或框架。&lt;frameset&gt; 定义框架集。&lt;h1to &lt;h6&gt; 定义 HTML 标题。&lt;head&gt; 定义关于文档的信息。&lt;header&gt; 定义 section 或 page 的页眉。&lt;hr&gt; 定义水平线。&lt;html&gt; 定义 HTML 文档。&lt;i&gt; 定义斜体字。&lt;iframe&gt; 定义内联框架。&lt;img&gt; 定义图像。&lt;input&gt; 定义输入控件。&lt;ins&gt; 定义被插入文本。&lt;isindex&gt; 不赞成使用。定义与文档相关的可搜索索引。&lt;kbd&gt; 定义键盘文本。&lt;keygen&gt; 定义生成密钥。&lt;label&gt; 定义 input 元素的标注。&lt;legend&gt; 定义 fieldset 元素的标题。&lt;li&gt; 定义列表的项目。&lt;link&gt; 定义文档与外部资源的关系。&lt;map&gt; 定义图像映射。&lt;mark&gt; 定义有记号的文本。&lt;menu&gt; 定义命令的列表或菜单。&lt;menuitem&gt; 定义用户可以从弹出菜单调用的命令/菜单项目。&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;meter&gt; 定义预定义范围内的度量。&lt;nav&gt; 定义导航链接。&lt;noframes&gt; 定义针对不支持框架的用户的替代内容。&lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。&lt;object&gt; 定义内嵌对象。&lt;ol&gt; 定义有序列表。&lt;optgroup&gt; 定义选择列表中相关选项的组合。&lt;option&gt; 定义选择列表中的选项。&lt;output&gt; 定义输出的一些类型。&lt;p&gt; 定义段落。&lt;param&gt; 定义对象的参数。&lt;pre&gt; 定义预格式文本。&lt;progress&gt; 定义任何类型的任务的进度。&lt;q&gt; 定义短的引用。&lt;rp&gt; 定义若浏览器不支持 ruby 元素显示的内容。&lt;rt&gt; 定义 ruby 注释的解释。&lt;ruby&gt; 定义 ruby 注释。&lt;s&gt; 不赞成使用。定义加删除线的文本。&lt;samp&gt; 定义计算机代码样本。&lt;script&gt; 定义客户端脚本。&lt;section&gt; 定义 section。&lt;select&gt; 定义选择列表（下拉列表）。&lt;small&gt; 定义小号文本。&lt;source&gt; 定义媒介源。&lt;span&gt; 定义文档中的节。&lt;strike&gt; 不赞成使用。定义加删除线文本。&lt;strong&gt; 定义强调文本。&lt;style&gt; 定义文档的样式信息。&lt;sub&gt; 定义下标文本。&lt;summary&gt; 为 &lt;details元素定义可见的标题。&lt;sup&gt; 定义上标文本。&lt;table&gt; 定义表格。&lt;tbody&gt; 定义表格中的主体内容。&lt;td&gt; 定义表格中的单元。&lt;textarea&gt; 定义多行的文本输入控件。&lt;tfoot&gt; 定义表格中的表注内容（脚注）。&lt;th&gt; 定义表格中的表头单元格。&lt;thead&gt; 定义表格中的表头内容。&lt;time&gt; 定义日期/时间。&lt;title&gt; 定义文档的标题。&lt;tr&gt; 定义表格中的行。&lt;track&gt; 定义用在媒体播放器中的文本轨道。&lt;tt&gt; 定义打字机文本。&lt;u&gt; 不赞成使用。定义下划线文本。&lt;ul&gt; 定义无序列表。&lt;var&gt; 定义文本的变量部分。&lt;video&gt; 定义视频。&lt;wbr&gt; 定义可能的换行符。 最后一点，总结在中干竞选的时候被问到的几个问题：1、盒子模型内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 2、块元素和行内元素在我看来就是换行和不换行的问题，块级元素需要换行而行内元素不需要。通过css可以进行转换12display:block; /*转换为块级*/display:inline; /*转换为行内*/ 3、权重问题CSS权重是由四个数值决定，内联样式、ID选择器、类选择器、类型选择器和伪元素选择器。第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为100。第三等：代表类，伪类和属性选择器，如.content，权值为10。第四等：代表类型选择器和伪元素选择器，如div p，权值为1。最后把这些值加起来，再就是当前元素的权重了。权重算出来了，但是某个元素到底用哪个样式，还有3个规则,：第一、如果样式上加有!important标记，例如：1p&#123; color: gray !important&#125; 那么始终采用这个标记的样式。第二、匹配的内容按照CSS权重排序，权重大的优先；可以看到，CSS权重只是决定应用哪个样式的其中一个步骤，不过这个步骤是最复杂的，上面已经说过了。第三、如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：12h1 &#123;color: blue&#125;h1 &#123;color: red&#125; 最终胜出的是color: red。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之表格输出]]></title>
    <url>%2F2018%2F04%2F19%2FQt4%2F</url>
    <content type="text"><![CDATA[&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x5728;C&#x4E2D;&#x7684;&#x7B97;&#x6CD5;&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x4E3B;&#x8981;&#x662F;&#x7531;&#x6211;&#x7684;&#x961F;&#x53CB; pedant &#x8D1F;&#x8D23;&#xFF0C;&#x5728;C&#x7684;&#x73AF;&#x5883;&#x4E2D;&#x7684;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110include &lt;stdio.h&gt;int save[8][8]=&#123;0,0&#125;; int table[1000][8] = &#123;0,0&#125;;int r = 1;int day[8] = &#123;0&#125;; void store()&#123; //找到一个方案之后储存到数组table中int i,j; for(j=1;j&lt;8;j++)&#123; for(i=1;i&lt;8;i++)&#123; if(save[i][j]==2) table[r][j] = i; &#125;&#125;r++;&#125;int can(int k,int j)&#123; //对于第k名员工在第J天是否可以休息进行判断int s=0,i;for(i=1;i&lt;8;i++) if(save[k][i]==2) s++;if(s&gt;1) return 0;for(s=0,i=1;i&lt;8;i++) if(save[i][j]==2) s++;if(s&gt;1) return 0; return 1;&#125; //符合要求，k在j可以休息，则返回1void dfs(int k)&#123; //深度优先搜索，从初始位置开始进行遍历，即从第K名员工开始int i,j;for(j=1;j&lt;8;j++) if(save[k][j]==1)&#123; //第k名员工将j设为自己的休息日 save[k][j]=2; //save[i][j]已经遍历过 if(can(k,j))&#123; //如果这天满足条件 if(k==7) //找到一个方案，储存到save中 store(); else dfs(k+1); //继续向下遍历 &#125; save[k][j]=1; //回溯，遍历下一个不同的休息日 &#125;&#125;int main()&#123;int i = 1,j = 1,k,temp[10][10] = &#123;0,0&#125;,cotp[8][8]; //储存初始数据的格式int jud = 1;char ch; for( ;i &lt; 8; i++)&#123; //员工信息的初始化，i代表各个员工的key，j代表该i对应的员工请假的日期。 do &#123; scanf(&quot;%d&quot;,&amp;save[i][j]); j++;&#125; while((ch = getchar())!=&apos;\n&apos;); j = 1; &#125;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125; &#125;if(jud)&#123; dfs(1); printf(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i = 1; i&lt;r; i++)&#123; //和qt交换数据时把print改成赋值，把putchar取消即可 for(j = 1; j&lt;8; j++)&#123; printf(&quot;%d &quot;,table[i][j]); &#125; putchar(&apos;\n&apos;);&#125;&#125;else&#123; printf(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) printf(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 printf(&quot;has no worker&quot;);&#125; getchar(); getchar();return 0;&#125; &#x6539;&#x5199;&#x4EE3;&#x7801;&#x5F53;&#x7136;&#xFF0C;&#x5728;Qt&#x4E2D;&#x76F4;&#x63A5;&#x5957;&#x7528;C&#x7684;&#x4EE3;&#x7801;&#x662F;&#x884C;&#x4E0D;&#x901A;&#x7684;&#xFF0C;&#x7279;&#x522B;&#x662F;&#x8FD8;&#x5B9A;&#x4E49;&#x4E86;&#x5176;&#x4ED6;&#x7684;&#x51FD;&#x6570;&#x3002;&#x6240;&#x4EE5;&#x5E94;&#x5F53;&#x8FDB;&#x884C;&#x9002;&#x5F53;&#x7684;&#x6539;&#x5199;&#xFF0C;&#x9996;&#x5148;&#x5C31;&#x9700;&#x8981;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x7684;private slots:&#x4E2D;&#x8FDB;&#x884C;&#x58F0;&#x660E; 1234private slots: void dfs(int k); int can(int k, int j); void store(); &#x58F0;&#x660E;&#x8FC7;&#x540E;&#x51FD;&#x6570;&#x518D;&#x5728;form.cpp&#x4E2D;&#x7F16;&#x5199;&#x5373;&#x53EF;&#xFF0C;&#x518D;&#x5BF9;&#x8F93;&#x5165;&#x8F93;&#x51FA;&#x90E8;&#x5206;&#x8FDB;&#x884C;&#x7B26;&#x5408;Qt&#x98CE;&#x683C;&#x7684;&#x6539;&#x7F16;&#x5373;&#x53EF;&#xFF0C;&#x5177;&#x4F53;&#x5728;Qt&#x4E2D;&#x8FD0;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int i=1,temp[10][10] = &#123; 0, 0 &#125;;int nnn=1;int m=0,e=0;QSqlQuery query;QString select_sql = &quot;select one, two, three, four, five, six, seven from work&quot;;if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125;else &#123; while(query.next()) //读入数据 &#123; save[i][1] = query.value(0).toInt(); save[i][2] = query.value(1).toInt(); save[i][3] = query.value(2).toInt(); save[i][4] = query.value(3).toInt(); save[i][5] = query.value(4).toInt(); save[i][6] = query.value(5).toInt(); save[i][7] = query.value(6).toInt(); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 i=i+1; &#125; &#125;int j = 1,k,cotp[8][8]; //储存初始数据的格式int jud = 1;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125;&#125;if(jud)&#123; dfs(1); qDebug(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;; if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 nnn=nnn+1; //e=e+1; &#125; &#125; m=m+1; &#125;&#125;else&#123; qDebug(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) //qDebug(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 QMessageBox::warning(this,tr(&quot;提示&quot;),QString(&quot;星期%1无法安排值班！&quot;).arg(i),QMessageBox::Yes); &#125;n2=r-1;qDebug(&quot;%d &quot;,m); &#x7531;&#x4E0A;&#x53EF;&#x4EE5;&#x770B;&#x51FA;C&#x7684;&#x7F16;&#x7801;&#x98CE;&#x683C;&#x5E76;&#x4E0D;&#x9002;&#x7528;&#x4E8E;Qt&#x5C3D;&#x7BA1;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#x4E86;&#xFF0C;&#x4F46;&#x662F;&#x4ECD;&#x7136;&#x5B58;&#x5728;&#x591A;&#x4E2A;&#x8B66;&#x544A;&#x65E0;&#x6CD5;&#x6D88;&#x9664;&#xFF0C;&#x6240;&#x4EE5;&#x8FD8;&#x662F;&#x5C3D;&#x91CF;&#x7528;C++&#x5427;&#xFF0C;&#x4E0D;&#x7136;&#x6539;&#x5199;&#x5F88;&#x9EBB;&#x70E6;&#x3002; &#x8868;&#x683C;&#x90E8;&#x5206;&#x6211;&#x7ED8;&#x5236;&#x8868;&#x683C;&#x91C7;&#x7528;&#x7684;&#x662F;&#x51FD;&#x6570;&#x7ED8;&#x56FE;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x63A7;&#x4EF6;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x597D;&#x5904;&#x662F;&#x53EF;&#x4EE5;&#x7CBE;&#x786E;&#x7684;&#x63A7;&#x5236;&#x8868;&#x683C;&#x5927;&#x5C0F;&#xFF0C;&#x9AD8;&#x5BBD;&#x7B49;&#x7B49;&#x3002; &#x8868;&#x683C;&#x7684;&#x521B;&#x5EFA;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x9700;&#x8981;&#x5148;&#x521B;&#x7ACB;&#x4E00;&#x4E2A;&#x9002;&#x5F53;&#x5927;&#x5C0F;&#x7684;tablewidget&#xFF0C;&#x7136;&#x540E;&#x518D;&#x521B;&#x5EFA;&#x5B57;&#x6BB5;&#x5B9A;&#x4E49;&#x5217;&#x5BBD;&#x884C;&#x5BBD;&#xFF0C;&#x6211;&#x7F16;&#x5199;&#x8FD9;&#x4E00;&#x6BB5;&#x5148;&#x662F;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;creatable&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x51FD;&#x6570;&#x4E2D;&#x8FDB;&#x884C;&#x521B;&#x5EFA;&#xFF0C;&#x5F53;&#x7136;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x53EF;&#x4EE5;&#x653E;&#x5165;&#x4E3B;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 12345678QTableWidget *tabl = new QTableWidget(this);tabl-&gt;setColumnCount(7); //设置列数tabl-&gt;setRowCount(5040); //设置行数/*设置列名*/QStringList headers;headers&lt;&lt;&quot;星期一&quot;&lt;&lt;&quot;星期二&quot;&lt;&lt;&quot;星期三&quot;&lt;&lt;&quot;星期四&quot;&lt;&lt;&quot;星期五&quot;&lt;&lt;&quot;星期六&quot;&lt;&lt;&quot;星期日&quot;;tabl-&gt;setHorizontalHeaderLabels(headers);tabl-&gt;resize(600,500); //设置大小尺寸 &#x8868;&#x683C;&#x6570;&#x636E;&#x7684;&#x8F93;&#x51FA;&#x5728;C&#x4E2D;&#x7684;&#x8868;&#x683C;&#x8F93;&#x51FA;&#x7528;&#x7684;&#x662F;printf&#xFF0C;&#x800C;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x4E2D;&#x9700;&#x8981;&#x7528;&#x5230;&#x7684;&#x8BED;&#x53E5;&#x662F;tabl-&gt;setItem&#xFF0C;&#x56E0;&#x6B64;&#x5C31;&#x9700;&#x8981;&#x5BF9;&#x8F93;&#x51FA;&#x6570;&#x636E;&#x8FDB;&#x884C;&#x6539;&#x5199;&#xFF0C;&#x800C;&#x5728;&#x8868;&#x683C;&#x4E2D;&#x7684;&#x8F93;&#x51FA;&#x53EA;&#x80FD;&#x6309;&#x987A;&#x5E8F;&#x8FDB;&#x884C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EA;&#x80FD;&#x6539;&#x53D8;&#x8981;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x7684;&#x6570;&#x636E;&#x7684;&#x987A;&#x5E8F;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 123456789101112131415161718192021for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;;//选择数据库 if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; //qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); nnn=nnn+1; &#125; &#125; m=m+1; &#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之主界面操作数据库]]></title>
    <url>%2F2018%2F04%2F19%2FQt3%2F</url>
    <content type="text"><![CDATA[&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x8BE5;&#x90E8;&#x5206;&#x4E3A;&#x672C;&#x6B21;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x6700;&#x4E3A;&#x5173;&#x952E;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x9996;&#x5148;&#x662F;&#x4F11;&#x606F;&#x65E5;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x6211;&#x4EEC;&#x5229;&#x7528;checkbox&#x63A7;&#x4EF6;&#x6765;&#x6536;&#x96C6;&#x7528;&#x6237;&#x6240;&#x9009;&#x62E9;&#x7684;&#x4F11;&#x606F;&#x65E5;&#x671F;&#xFF0C;&#x5C06;&#x5176;&#x50A8;&#x5B58;&#x5728;&#x8BBE;&#x7F6E;&#x597D;&#x7684;&#x4E03;&#x4E2A;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#x518D;&#x5C06;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;idcard&#x8FDB;&#x884C;&#x5916;&#x90E8;&#x8C03;&#x7528;&#x4F5C;&#x4E3A;&#x5199;&#x5165;&#x6570;&#x636E;&#x7684;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x5E93;&#x7531;7&#x4E2A;&#x6570;&#x5916;&#x52A0;id&#x3001;workname&#x3001;workcall&#x7EC4;&#x6210;&#x3002; &#x4E3B;&#x754C;&#x9762;&#x90E8;&#x5206;&#x4E3B;&#x754C;&#x9762;&#x4E3B;&#x8981;&#x6D89;&#x53CA;&#x4E24;&#x4E2A;&#x96BE;&#x70B9;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x3002; Checkbox&#x7684;&#x4F7F;&#x7528;&#x5BF9;&#x4E8E;Checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x5173;&#x952E;&#x7684;&#x5730;&#x65B9;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x5224;&#x65AD;&#x8FD9;&#x4E2A;&#x63A7;&#x4EF6;&#x6709;&#x6CA1;&#x6709;&#x88AB;&#x9009;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789if (state == Qt::Checked) // 选中 &#123; a1=1; qDebug()&lt;&lt;&quot;周一ok!&quot;; &#125;else //未选 &#123; a1=0; &#125; &#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x6211;&#x4EEC;&#x5C06;7&#x4E2A;&#x4F11;&#x606F;&#x65E5;&#x6240;&#x5BF9;&#x5E94;&#x7684;&#x63A7;&#x4EF6;&#x7684;&#x69FD;&#x51FD;&#x6570;&#x7F16;&#x5199;&#x597D;&#x4E86;&#x4E4B;&#x540E;&#xFF0C;7&#x4E2A;&#x6570;&#x636E;&#x5DF2;&#x7ECF;&#x5B58;&#x5165;&#x6211;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x8981;&#x505A;&#x7684;&#x5C31;&#x662F;&#x5C06;7&#x4E2A;&#x53D8;&#x91CF;&#x5B58;&#x5165;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool ok=database.open();if(idcard==0)&#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;管理员无法进行该操作！&quot;),QMessageBox::Yes);&#125;else&#123; if (!ok) &#123; qDebug() &lt;&lt; &quot;Error: Failed to connect database.&quot; &lt;&lt; database.lastError(); &#125; else &#123; // do something &#125; QSqlQuery query; //插入数据 query.prepare(insert_sql); query.addBindValue(idcard); //id query.addBindValue(a1); //1 query.addBindValue(a2); //2 query.addBindValue(a3); //3 query.addBindValue(a4); //4 query.addBindValue(a5); //5 query.addBindValue(a6); //6 query.addBindValue(a7); //7 query.addBindValue(workname); //workname query.addBindValue(workcall); //workcall QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;提交信息成功！&quot;),QMessageBox::Yes); if(!query.exec()) &#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;无法重复提交信息！&quot;),QMessageBox::Yes); qDebug()&lt;&lt;query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;inserted!&quot;; &#125;&#125;//核心语句仅为 QSqlQuery query; query.prepare(insert_sql); query.addBindValue(写入的变量名); &#x5176;&#x5B9E;&#x5229;&#x7528;Qt&#x5BF9;sqlite&#x7684;&#x64CD;&#x4F5C;&#x5E76;&#x4E0D;&#x590D;&#x6742;&#xFF0C;&#x6838;&#x5FC3;&#x90E8;&#x5206;&#x5176;&#x5B9E;&#x5341;&#x5206;&#x7B80;&#x5355;&#xFF0C;&#x5927;&#x90E8;&#x5206;&#x521D;&#x5B66;&#x8005;&#xFF08;&#x5305;&#x62EC;&#x6211;&#xFF09;&#x90FD;&#x5C06;&#x6570;&#x636E;&#x5E93;&#x60F3;&#x8C61;&#x7684;&#x592A;&#x96BE;&#x592A;&#x96BE;&#x4E86;&#xFF0C;&#x5176;&#x5B9E;&#x975E;&#x4E5F;&#x3002;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之注册与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt2%2F</url>
    <content type="text"><![CDATA[&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x662F;&#x6211;&#x8BA4;&#x4E3A;&#x6BD4;&#x8F83;&#x96BE;&#x7684;&#x90E8;&#x5206;&#x4EC5;&#x6B21;&#x4E8E;&#x540E;&#x9762;&#x6392;&#x73ED;&#x8868;&#x683C;&#x7684;&#x8F93;&#x51FA;&#xFF0C;&#x96BE;&#x70B9;&#x4E3B;&#x8981;&#x662F;&#x63D2;&#x5165;&#x6570;&#x636E;&#x548C;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x91CD;&#x590D;&#x8FD9;&#x4E24;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x67E5;&#x8BE2;&#x6570;&#x636E;&#x4E4B;&#x524D;&#x5728;&#x767B;&#x5F55;&#x90E8;&#x5206;&#x5C31;&#x6709;&#x63D0;&#x8FC7;&#x4ECE;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x90A3;&#x4E2A;&#x662F;&#x901A;&#x8FC7;&#x67E5;&#x8BE2;name&#x5B57;&#x6BB5;&#x6765;&#x5B9E;&#x73B0;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x627E;&#x5230;&#x5BC6;&#x7801;&#xFF0C;&#x8FD9;&#x4E2A;&#x5927;&#x540C;&#x5C0F;&#x5F02;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x6765;&#x67E5;&#x627E;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x4E0E;&#x524D;&#x9762;&#x7C7B;&#x4F3C;&#xFF0C;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D58;&#x8FF0;&#x4E86;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142//查询部分数据(name)if(!sql_query.exec(select_sql))&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(1) &#123; if(sql_query.next()) //name有数据 &#123; QString name = sql_query.value(&quot;name&quot;).toString(); qDebug()&lt;&lt;QString(&quot;name=%1&quot;).arg(name); if(ui-&gt;nameLineEdit-&gt;text()==name) //用户名已经存在 &#123; ui-&gt;nameLineEdit-&gt;setFocus(); nameFlag=false; break; &#125; else &#123; //newname=ui-&gt;nameLineEdit-&gt;text(); nameFlag=true; &#125; &#125; else &#123; //name列为空 nameFlag=true; break; &#125; &#125;&#125;newchatid=max_id+1;if(nameFlag==true) newname=ui-&gt;nameLineEdit-&gt;text();else return;if(passwdFlag==true) newpasswd=ui-&gt;passwd1LineEdit-&gt;text();else return; &#x63D2;&#x5165;&#x6570;&#x636E;&#x5F53;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x800C;&#x4E14;&#x7528;&#x6237;&#x6CE8;&#x518C;&#x6210;&#x529F;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x9700;&#x8981;&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x63D2;&#x5165;&#x65B0;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BBE;&#x5B9A;&#x4E00;&#x4E2A;id&#xFF0C;&#x901A;&#x8FC7;&#x6700;&#x5927;id&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5C3E;&#x90E8; 123456789101112131415//查询最大idmax_id = 0;sql_query.prepare(select_max_sql);if(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(sql_query.next()) &#123; max_id = sql_query.value(0).toInt(); qDebug()&lt;&lt;QString(&quot;max chatid:%1&quot;).arg(max_id);//输出最大ID在Debug界面 &#125;&#125; &#x6700;&#x5927;ID&#x627E;&#x5230;&#x540E;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x518D;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;newID=max_id+1&#x6765;&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x5C3E;&#x90E8;&#x7684;&#x4E0B;&#x4E00;&#x7EC4;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E; 1234567891011121314151617//插入数据sql_query.prepare(insert_sql);sql_query.addBindValue(newID); //idsql_query.addBindValue(newpasswd); //passwdsql_query.addBindValue(newname); //namesql_query.addBindValue(newemail); //emailsql_query.addBindValue(0); //historyif(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; qDebug()&lt;&lt;&quot;inserted!&quot;; //插入成功&#125;this-&gt;close(); &#x5F39;&#x7A97;&#x5728;&#x4E4B;&#x524D;&#x7684;&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;&#x767B;&#x5F55;&#x9519;&#x8BEF;&#x3001;&#x7528;&#x6237;&#x540D;&#x91CD;&#x590D;&#x7B49;&#x4FE1;&#x606F;&#x9700;&#x8981;&#x4F20;&#x8FBE;&#x7ED9;&#x4F7F;&#x7528;&#x8005;&#xFF0C;&#x8FD9;&#x65F6;&#x5C31;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5F39;&#x7A97;&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x5165; QMessageBox &#x5373;&#x53EF;&#x3002; 123QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;喂！\n 你两次密码输的不一样，你是不是傻？！&quot;),QMessageBox::Yes);ui-&gt;passwd2LineEdit-&gt;clear();//清空密码输入栏ui-&gt;passwd2LineEdit-&gt;setFocus();//将鼠标定位到密码输入栏]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之登录与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt1%2F</url>
    <content type="text"><![CDATA[&#x5728;&#x4E0A;&#x4E00;&#x5468;&#x7684;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x5468;&#x8FD0;&#x7528;Qt&#x5BF9;&#x8001;&#x5E08;&#x7ED9;&#x51FA;&#x7684;&#x8BFE;&#x9898;(&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;)&#x8FDB;&#x884C;&#x4E86;UI&#x754C;&#x9762;&#x7684;&#x8BBE;&#x8BA1;&#xFF0C;&#x5728;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#x6709;&#x4E86;&#x4E0D;&#x5C0F;&#x7684;&#x6536;&#x83B7;&#xFF0C;&#x7279;&#x6B64;&#x4E0E;&#x5927;&#x5BB6;&#x4E00;&#x8D77;&#x5206;&#x4EAB;&#xFF0C;&#x4E0D;&#x559C;&#x52FF;&#x55B7;&#xFF01; &#x8BBE;&#x8BA1;&#x601D;&#x8DEF;&#x8BE5;&#x8BFE;&#x9898;&#x4E3A;&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;&#xFF0C;&#x5BF9;&#x767B;&#x5F55;&#x3001;&#x6CE8;&#x518C;&#x3001;&#x4F11;&#x606F;&#x65E5;&#x9009;&#x62E9;&#x3001;&#x6392;&#x73ED;&#x5747;&#x6709;&#x8981;&#x6C42;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x8BBE;&#x7F6E;&#x4E86;&#x56DB;&#x4E2A;&#x7A97;&#x53E3;&#x6765;&#x5206;&#x522B;&#x5BF9;&#x5E94;&#x56DB;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x767B;&#x5F55;&#x90E8;&#x5206;&#x9996;&#x5148;&#x662F;&#x767B;&#x5F55;&#x90E8;&#x5206;&#xFF0C;&#x65E2;&#x7136;&#x662F;&#x767B;&#x5F55;&#x90A3;&#x4E48;&#x80AF;&#x5B9A;&#x4F1A;&#x6D89;&#x53CA;&#x5230;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x7684;&#x5339;&#x914D;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FD9;&#x91CC;&#x91C7;&#x7528;&#x7684;&#x662F;sqlite&#x4F5C;&#x4E3A;&#x6570;&#x636E;&#x5E93;&#x6765;&#x50A8;&#x5B58;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x4EE5;&#x53CA;&#x7535;&#x8BDD;&#x53F7;&#x7801;&#x7B49;&#x6570;&#x636E;&#x3002;&#x6D89;&#x53CA;&#x5230;&#x6570;&#x636E;&#x5E93;&#x4E0E;Qt&#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x4EA4;&#x4E92;&#xFF0C;&#x5177;&#x4F53;&#x6570;&#x636E;&#x5E93;&#x7684;&#x521B;&#x5EFA;&#x3001;&#x8F93;&#x51FA;&#x548C;&#x8F93;&#x5165;&#x540E;&#x9762;&#x4F1A;&#x8BB2;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x8BB2;Qt&#x548C;&#x6570;&#x636E;&#x7684;&#x8FDE;&#x63A5;&#x3002; &#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x5728;login.cpp&#x4E2D; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//打开数据库if(!database.open())&#123; qDebug()&lt;&lt;database.lastError(); //打开失败 qFatal(&quot;failed to connect.&quot;) ;&#125;else&#123; qDebug()&lt;&lt;&quot;open seccess&quot;; QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效 sql_query.prepare(select_table); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; QString tableName; while(sql_query.next()) &#123; tableName = sql_query.value(0).toString(); qDebug()&lt;&lt;tableName; if(tableName.compare(&quot;user&quot;)) //打开名为user的数据库 &#123; tableFlag=false; qDebug()&lt;&lt;&quot;table is not exist&quot;; &#125; else &#123; tableFlag=true; qDebug()&lt;&lt;&quot;table is exist&quot;; &#125; &#125; &#125; if(tableFlag==false) //该数据库不存在就创建一个user的数据库 &#123; sql_query.prepare(create_sql); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;table created!&quot;; &#125; &#125; //database.close();&#125;//先判断数据库能否打开再判断是否数据库存在。 &#x8FD9;&#x4E00;&#x6BB5;&#x4EE3;&#x7801;&#x653E;&#x5728;Login::Login(QWidget *parent) :&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;open seccess&#xFF0C;&#x521B;&#x5EFA;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;table created!&#xFF0C;&#x6253;&#x5F00;&#x5931;&#x8D25;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;failed to connect.&#x3002; &#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8BE5;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8F83;&#x4E3A;&#x7B80;&#x964B;&#xFF0C;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x662F;&#x901A;&#x8FC7;&#xFF1A; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x7528;&#x6237;&#x540D;&#x3002; &#x5BF9;&#x6570;&#x636E;&#x5E93;&#x8FDB;&#x884C;&#x68C0;&#x7D22;&#xFF0C;&#x82E5;&#x53EF;&#x4EE5;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;&#x5BC6;&#x7801;&#x5219;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5BC6;&#x7801;&#x548C;ID&#xFF0C;&#x82E5;&#x4E0D;&#x80FD;&#x627E;&#x5230;&#x5219;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x3002; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x5BC6;&#x7801;&#x4E0E;&#x4E4B;&#x524D;&#x68C0;&#x7D22;&#x51FA;&#x6765;&#x7684;&#x5BC6;&#x7801;&#x8FDB;&#x884C;&#x5339;&#x914D;&#x3002; &#x5224;&#x65AD;&#x662F;&#x5426;&#x767B;&#x5F55;&#x6210;&#x529F; 12345678910111213141516171819202122if(matchFlag==false)&#123;//用户名错误qDebug()&lt;&lt;&quot;name invalid&quot;;&#125;else&#123;if(usr_passwd!=ui-&gt;passwdLineEdit-&gt;text())&#123;//密码错误qDebug()&lt;&lt;&quot;passwd not match&quot;;&#125;else&#123;//用户名和密码均正确mainwindow cw(this);this-&gt;hide();cw.show();cw.exec();this-&gt;close(); &#125; &#125; &#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x5F53;&#x6570;&#x636E;&#x5E93;&#x548C;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x90FD;&#x5199;&#x597D;&#x540E;&#xFF0C;&#x65B0;&#x7684;&#x95EE;&#x9898;&#x6765;&#x4E86;&#xFF0C;&#x5728;Qt&#x4E2D;&#x5982;&#x4F55;&#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x5462;&#xFF1F;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x5148;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x628A;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;&#x5B58;&#x5165;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效//查询部分数据(name)QString tempstring=&quot;select * from user where name=&apos;&quot;+name+&quot;&apos;&quot;;//查询的字段为nameqDebug()&lt;&lt;tempstring;if(!sql_query.exec(tempstring))&#123; qDebug()&lt;&lt;sql_query.lastError(); matchFlag=false;&#125;else&#123; while(sql_query.next()) &#123; //将数据存入自己定义的变量中 usr_id = sql_query.value(0).toInt(); usr_passwd = sql_query.value(1).toString(); usr_name = sql_query.value(2).toString(); usr_email = sql_query.value(3).toString(); usr_history = sql_query.value(4).toInt(); &#125; //比如sql_query.value(0).toInt(); //其中的value（0）表示读取的是第几个字段 //toInt（）表示的是读取的数据类型]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
