<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo 搭博客踩坑大全]]></title>
    <url>%2F2018%2F10%2F19%2Fhexo-%E6%90%AD%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Git+hexo 搭博客 作为一个老学长帮新生搭博客，在这过程中遇到了许多坑，什么大小写问题全角标点不注意空格看不到之类的已经数不胜数了，下面有几点要注意！！！！！！ 仔细看好大小写注意全角和半角的切换配置里冒号后面都有空格安装Git bash，安装Nodejs，注册Github安装Git bash和Nodejs直接在官网安装就好了，然后到github上注册账号 安装hexo安装hexo的话，打开cmd输入npm i -g hexo,如果加载速度过慢或者不动的话建议换一个网络试试 生成ssh key生成ssh key打开你的Git bash，输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot;,接下来连续三个回车出现一个个人ssh key，然后再输入cd ~/.ssh之后输入cat id_rsa.pub会出现一串以ssh-rsa开头的一段公钥。复制打开你的github在设置中找到SSH and GPG keys建立一个新的SSH keys。 配置博客前面的做好之后打开你之前建立的博客文件夹找到一个名为_config.yml（冒号之后都是有一个半角空格）1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到Git bash进入blog，执行123hexo cleanhexo ghexo s 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。打开浏览器http://localhost:4000就可以看到你的博客了 部署项目先安装：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）安装好后执行123hexo cleanhexo generatehexo deploy 在浏览器中输入http://你的用户名.github.io就可以看到你的个人博客啦，是不是很兴奋！]]></content>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2018%2F08%2F11%2FReact%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
    <content type="text"><![CDATA[render外层嵌套的divrander函数return只能返回一个大的JSX，如果出现两个就需要在外面套一个&lt;div&gt;&lt;/div&gt;但是多出来的一个不必要的div会给我们增加许多的麻烦所以就可以用&lt;React.fragment&gt;&lt;/React.fragment&gt;来取代&lt;div&gt;&lt;/div&gt;。 关于key值的warningWarning: Each child in an array or iterator should have a unique “key” prop.这个Warning代表缺少key值，补充一下key值的是干嘛的： 当我们组件状态更新后，会重新渲染组件，渲染组件的时候会一个个去根据key值的情况去渲染：A. 渲染前的key值存在，则去寻找这个key值对应的组件： a.组件数据不变，则不重新渲染这个组件； b.若组件数据改变，则渲染改变的这一部分数据；B.渲染前的key值不存在，则会销毁这个key值对应的组件：C.出现新的key值，则渲染一个新的key值对应的组件； 父组件与子组件的通信将网页拆分成多个组件之后还可以将大的组件继续拆分，所以就出现了子组件，但是父组件与子组件是如何通信的呢？父组件向子组件传值，这个比较容易理解，例如&lt;TodoItem handDelete={this.handDelete.bind(this)} key={index} index={index} content={item}/&gt;中的content就是向子组件传递了一个item值，在子组件接手数据的时候则是this.props.content等于父组件中的item值。子组件如何与父组件通信总的来说就是通过函数传递，父组件那边写好了处理子组件数据的函数并传给子组件，子组件调用函数并传入数据，父组件就可以接收数据并存储。 React里面写函数有特定的规则React里面写函数有特定的规则，例如onClick={this.handleBtnClick.bind(this)}与普通JavaScript不同的是大小写和花括号的区别，调用css的区别也差不多用的是className={style}而不是class=“style”。 JSX注释123456在JSx中注释与在JavaScript中略有不同，之前说过在JSX想写js的话需要加一个&#123; &#125;写注释的时候同理&#123;/*这是注释*/&#125;单行注释比较麻烦&#123;//这是注释&#125; 输入不转译&lt;li&gt;dangerrouslySetInnerHTML={{__html: item}}&lt;/li&gt; 利用lable聚焦123&lt;lable&gt;输入聚焦&lt;lable htmlFor=&quot;a&quot;&gt;输入内容&lt;/lable&gt;&lt;input id=&quot;a&quot;&gt; 关于Registerserviceworkerimport Registerserviceworker from ‘Registerserviceworker’；PWA progressive web application,它在有https协议的服务器上缓存可以离线运行。 科普PWAPWA全称Progressive Web App，直译是渐进式WEB应用，是 Google 在 2015 年提出，2016年6月才推广的项目。是结合了一系列现代Web技术的组合。在网页应用中实现和原生应用相近的用户体验。所谓的P（Progressive）这里有两层含义，一方面是渐进增强，让WEB APP的体验和功能能够用渐进增强的方式来更接近原生APP的体验及功能。另一方面是指下一代WEB技术。PWA并非描写叙述一个技术。而是一些技术的合集。 propTypes与defaultPropspropTypes顾名思义prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型。eg：1234567891011121314151617yourComponent.propTypes = &#123; 属性1：属性1的变量类型， 属性2：属性2的变量类型 //...&#125;XX.propTypes = &#123; optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型 number:PropTypes.oneOfType( [PropTypes.string,PropTypes.number] )//规定多个检测通过的数据类型&#125; defaultPropsReact组件的默认状态（defaultProps），给你的数据设定默认数据。eg：123456789101112131415161718192021222324class XX extends React.Component &#123; constructor(props)&#123; super(props); this.state=&#123; name:props.name &#125;; &#125;&#125;XX.defaultProps=&#123; name:&apos;default name&apos;&#125;;orconst XXX=(props)=&gt;&#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; );&#125;XXX.defaultProps=&#123; name:&apos;default name&apos;&#125;; state props renderprops设置 props 的方式1）可以在组件挂载时设置props：123456var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);React.render(&lt;HelloWorld name=&quot;Sam&quot; /&gt;, document.body); 2）也可以通过调用组件实例的setProps()方法来设置props（在ES6中将被禁用，这个方法不支持ES6类组件React.Component扩展。）1234567var HelloWorld = React.createClass(&#123; render: function()&#123; return &lt;p&gt;Hello, &#123;this.props.name ? this.props.name : &quot;World&quot;&#125;&lt;/p&gt; &#125;&#125;);var instance = React.render(&lt;HelloWorld/&gt;, document.body);instance.setProps(&#123;name: &apos;Tim&apos;&#125;); prop 支持的数据类型我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop：&lt;App id=&quot;sample&quot; borderWidth={2} onClick={onButtonClick}/&gt;在上面的例子中，创建了名为 App 的组件实例，使用了名字分别为id、borderWidth、onClick和style的 prop，看起来，React组件的 prop 很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌的JavaScript，也依然是字符串形式表示代码。React组件的 prop 所能支持的类型则丰富得多，可以是任何一种JavaScript语言支持的数据类型。比如在上面的App中，borderWidth就是数字类型，onClick是函数类型，style的值是一个包含color字段的对象，当 prop 的类型不是字符串类型时，在JSX中必须用花括号{}把 prop 值包住，所以style的值有两层花括号，外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量。当外部世界要传递一些数据给React组件，一个最直接的方式就是通过 prop；同样，React组件要反馈数据给外部世界，也可以用 prop，因为 prop 的类型不限于纯数据，也可以是函数，函数类型的 prop 等于让父组件交给了子组件一个回调函数，子组件在恰当的实际调用函数类型的 prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。不要修改props这样是反模式，因为 React 不能帮你检查属性类型（propTypes）。这样即使你的属性类型有错误也不能得到清晰的错误提示。Props 应该被当作禁止修改的。修改 props 对象可能会导致预料之外的结果，所以最好不要去修改 props 对象。关于super(props)如果一个组件需要定义自己的构造函数，一定要记得在构造函数的第一行通过 super 调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过 this.props 访问到父组件传递过来的 props 值。 关于 statethis.state 与 this.setState在代码中，通过 this.state 可以读取到组件的当前 state。值得注意的是，我们改变组件 state 必须要使用 this.setState 函数，而不能直接去修改 this.state 。直接修改 this.state 的值，虽然事实上改变了组件的内部状态，但只是野蛮地修改了 state，却没有驱动组件进行重新渲染，既然组件没有重新渲染，当然不会反应 this.state 值的变化；而 this.setState() 函数所做的事情，首先是改变 this.state 的值，然后驱动组件经历更新过程，这样才有机会让 this.state 里新的值出现在界面上。构造函数 constructor初始化 state，因为组件生命周期中任何函数都可能要访问 state，那么整个生命周期中第一个被调用的构造函数自然是初始化 state 最理想的地方；绑定成员函数的 this 环境；在ES6语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的。而在构造函数中，this 就是当前组件实例，所以，为了方便将来的调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前实例。 render通常一个组件要发挥作用，总是要渲染一些东西，render 函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。（render函数并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。）需要注意，render 函数应该是一个纯函数，完全根据 this.state 和this.props 来决定返回的结果，而且不要产生任何副作用。在 render 函数中去调用this.setState 毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。父组件的render运行时子组件的render自动被重新运行一次 虚拟DOM1、state 数据2、JSX 模板3、生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实的DOM）[&#39;idv&#39;,{id:&#39;abc&#39;},[&#39;span&#39;,{},&#39;hello world&#39;]]4、用虚拟结构的DOM生成真实的DOM&lt;div id=&#39;a&#39;&gt;&lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;5、state发生变化6、生成新的虚拟DOM7、比较原始虚拟DOM和新的虚拟DOM的区别，找到区别的内容 Diff，当第一层不同的时候删除以下所有DOM节点，用新的替换， 同层比较，算法简单，与key值做关联。index不作为key值的理由：删除一个节点所有index发生变化与旧的虚拟DOM不相同无法建立关联损耗性能 8、直接操作DOM替换其中不同的地方优点：1、性能提升了2、它使得跨端应用得以实现，React Native。3、JSX -&gt; Js对象(React.createElement) -&gt; 真实的DOM（不用去繁琐的使用React.createElement(&#39;div&#39;,{},&#39;item&#39;)）//React.createElement(&#39;div&#39;,{},&#39;item&#39;)是更为底层的语法 生命周期函数生命周期函数指在某一个时刻组件会自动调用执行的函数，render就是一个生命周期函数。组件经历过的几个过程：初始化定义state接收props挂载 componentWillMount（组件即将被挂载到页面的时候执行） render componentDidMount（组件被挂载之后执行） 组件更新 当数据（props、state）发生变化时执行生命周期函数，shouldComponentUpdata(组件即将被变更)产生布尔返回值，true是需要改变组件，false不需要更新。 componentWillUpdata（组件被更新之前shouldComponentUpdata返回true执行）。 render重新渲染。 componentDidUpdata（组件更新完成之后执行）。componentWillReceiveProps（没有props的情况下不会被执行，顶层组件没有接收所以不会调用。当一个组件从父组接收参数，只要父组件的render函数被重新执行了，子组件的这个函数就会被执行） 去除挂载 componentWillUnmount（当这个组件即将被从页面种剔除的时候执行的函数） 所有生命周期函数可以不存在，render函数必须存在，因为之前继承了component里面就已经有了]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React快速入门]]></title>
    <url>%2F2018%2F08%2F11%2FReact01%2F</url>
    <content type="text"><![CDATA[开发环境搭建首先搭建node环境（后面细讲），然后到react官网看官方文档里的Create React App里的两端代码，我是在Windows下所以打开cmd输入npx create-react-app my-app之后cd到安装目录下执行npm start就自动构建成了新的项目，至于webpack啥的还没开始学就先不讲了。 精简代码在npm start执行后自动在浏览器打开了一个页面，找到你之前创建了的文件夹，src文件里存放着代码，index.js是这个项目的入口文件，registerServiceWorker是pwa（离线页面），现在用不到可以先精简了，还有import ./index。css这个是样式文件也可以精简了，最后留下三句话就够了import React, {Component,Fragment} from &#39;react&#39;;import TodoItem from &#39;./TodoItem&#39;; 什么是组件React是基于组件的框架，组件就是将网页局部化，将一个大的网页分成大的几块这就是组件，这些组件再拆分成小组件。打开index.js组件就是从 import A from &quot;./A&quot;引入而ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&#39;root&#39;));则是在一个id为root的地方进行渲染 JSXJavaScript与xml，在代码中可以轻松的使用html标签而不会报错，而想使用JavaScript的时候加一个{}就好了，但是只可以是表达式而不是语句。eg：1234567891011121314151617class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); this.handleItemClick=this.handleItemClick.bind(this); &#125; handleItemClick()&#123; this.props.handDelete(this.props.index); &#125; render()&#123; const &#123;content&#125;=this.props; return ( &lt;div&gt; &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;content&#125;&lt;/li&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About css选择器]]></title>
    <url>%2F2018%2F08%2F02%2FAbout-css%2F</url>
    <content type="text"><![CDATA[写在前面的话在我看来css是我在编程过程中最头疼的几个问题之一，首先是定位问题，对css元素、选择器不熟悉的话肯定要出问题，其次就是浮动问题，最后就是响应式布局，这里我主要就是记录css，其他的后面再单独记录。 css的选择器css的选择器大致可以分为： 元素选择器元素选择器，最基本的选择器，如果设置 HTML 的样式，选择器通常将是某个 HTML 元素，比如 p、h1、em、a，甚至可以是 html 本身。eg:123html &#123;color:black;&#125;h1 &#123;color:blue;&#125;h2 &#123;color:silver;&#125; 类选择器类选择器，类选择器允许以一种独立于文档元素的方式来指定样式。在使用类选择器之前，需要修改具体的文档标记，以便类选择器正常工作。为了将类选择器的样式与元素关联，必须将 class 指定为一个适当的值。通过class来获取事先指定好的样式。eg:1&lt;h1 class=&quot;important&quot;&gt;&lt;/css&gt; 1.important &#123;color:red;&#125; ID选择器ID选择器，ID 选择器类似于类选择器，不过也有一些重要差别，ID 选择器前面有一个#号，ID 选择器不引用 class 属性的值，毫无疑问，它要引用 id 属性中的值。与类不同，在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次。不同于类选择器，ID 选择器不能结合使用，因为 ID 属性不允许有以空格分隔的词列表。eg:1&lt;p id=&quot;intro&quot;&gt;hello world.&lt;/p&gt; 1*#intro &#123;font-weight:bold;&#125; 属性选择器属性选择器，CSS 2 引入了属性选择器。属性选择器可以根据元素的属性及属性值来选择元素，这个东西我并不经常用，因为我感觉比较玄，一般都是用上面几种。这个就大致讲一下用法，大概就是指定一个标签，然后这种标签带有特定属性的都被选择。eg:1234a[href][title] &#123;color:red;&#125;//可以只对有 href 属性的锚（a 元素）应用样式img[alt] &#123;border: 5px solid red;&#125;//可以对所有带有 alt 属性的图像应用样式，从而突出显示这些有效的图像 后代选择器后代选择器，根据上下文选择元素，我们可以定义后代选择器来创建一些规则，使这些规则在某些文档结构中起作用，而在另外一些结构中不起作用。后代选择器的功能极其强大。有了它，可以使 HTML 中不可能实现的任务成为可能。假设有一个文档，其中有一个边栏，还有一个主区。边栏的背景为蓝色，主区的背景为白色，这两个区都包含链接列表。不能把所有链接都设置为蓝色，因为这样一来边栏中的蓝色链接都无法看到。eg：12345css部分div.sidebar &#123;background:blue;&#125;div.maincontent &#123;background:white;&#125;div.sidebar a:link &#123;color:white;&#125;div.maincontent a:link &#123;color:blue;&#125; 12345678910111213141516171819html部分&lt;ul&gt; &lt;li&gt;List item 1 &lt;ol&gt; &lt;li&gt;List item 1-1&lt;/li&gt; &lt;li&gt;List item 1-2&lt;/li&gt; &lt;li&gt;List item 1-3 &lt;ol&gt; &lt;li&gt;List item 1-3-1&lt;/li&gt; &lt;li&gt;List item &lt;em&gt;1-3-2&lt;/em&gt;&lt;/li&gt; &lt;li&gt;List item 1-3-3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 1-4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt; 子元素选择器子元素选择器，这个选择器与后代选择器类似，不过区别于后代选择器它只能选择某个元素的子元素。eg:1h1 &gt; strong &#123;color:red;&#125; 1&lt;h1&gt; hello &lt;strong&gt;world&lt;/strong&gt;&lt;/h1&gt; 相邻兄弟选择器相邻兄弟选择器,子元素选择器、后代选择器、相邻兄弟选择器这三个选择器效果都差不多，只不过一个选择器比一个选择器缩小了范围而已，后代选择的是所有后代，子元素是某个元素的所有子元素，相邻兄弟选择器是选择下一个或者上一个。eg:12h1 + p &#123;margin-top:50px;&#125;//选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素 就写到这里吧，css的选择器是比较关键的，其他的过几天再总结，就这样~]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About html]]></title>
    <url>%2F2018%2F08%2F02%2Fabout-html%2F</url>
    <content type="text"><![CDATA[写在前面的一些话入门前端也有不短的一段时间了自己前前后后也看了许多教程和视频，也算是入了前端的坑了吧，感觉前端学习的东西太杂了怕自己捋不清所以写下笔记记录一下。 Html DOM html在我看来如果不算H5的话它就好比一幢楼房的钢筋部分，html的语法并不难甚至可以说是很简单，标签也越来越语义化，但是学习html是为了让你对DOM树有一种感觉，就好像在开始建造房屋时你得想好需要建多高每层要搭建一些什么东西。在一些小页面可能无法体现，但是到了大型网站这就变得至关重要了。 这其实也是一个节点图，文档中的所有内容、所以标签都可以视为一个节点，这样就可以利用节点做许多操作，例如： ① 查询某个元素 ② 查询某个元素的祖先、兄弟以及后代元素 ③ 获取、修改元素的属性 ④ 获取、修改元素的内容 ⑤ 创建、插入和删除元素 关于这些操作涉及到了JavaScript所以这里就不细讲了，总之学习html在掌握语法的同时也要构建一种DOM树的思想。 标签的用法总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;a&gt; 定义锚。&lt;abbr&gt; 定义缩写。&lt;acronym&gt; 定义只取首字母的缩写。&lt;address&gt; 定义文档作者或拥有者的联系信息。&lt;applet&gt; 不赞成使用。定义嵌入的 applet。&lt;area&gt; 定义图像映射内部的区域。&lt;article&gt; 定义文章。&lt;aside&gt; 定义页面内容之外的内容。&lt;audio&gt; 定义声音内容。&lt;b&gt; 定义粗体字。&lt;base&gt; 定义页面中所有链接的默认地址或默认目标。&lt;basefont&gt; 不赞成使用。定义页面中文本的默认字体、颜色或尺寸。&lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置。&lt;bdo&gt; 定义文字方向。&lt;big&gt; 定义大号文本。&lt;blockquote&gt; 定义长的引用。&lt;body&gt; 定义文档的主体。&lt;br&gt; 定义简单的折行。&lt;button&gt; 定义按钮 (push button)。&lt;canvas&gt; 定义图形。&lt;caption&gt; 定义表格标题。&lt;center&gt; 不赞成使用。定义居中文本。&lt;cite&gt; 定义引用(citation)。&lt;code&gt; 定义计算机代码文本。&lt;col&gt; 定义表格中一个或多个列的属性值。&lt;colgroup&gt; 定义表格中供格式化的列组。&lt;command&gt; 定义命令按钮。&lt;datalist&gt; 定义下拉列表。&lt;dd&gt; 定义定义列表中项目的描述。&lt;del&gt; 定义被删除文本。&lt;details&gt; 定义元素的细节。&lt;dir&gt; 不赞成使用。定义目录列表。&lt;div&gt; 定义文档中的节。&lt;dfn&gt; 定义定义项目。&lt;dialog&gt; 定义对话框或窗口。&lt;dl&gt; 定义定义列表。&lt;dt&gt; 定义定义列表中的项目。&lt;em&gt; 定义强调文本。&lt;embed&gt; 定义外部交互内容或插件。&lt;fieldset&gt; 定义围绕表单中元素的边框。&lt;figcaption&gt; 定义 figure 元素的标题。&lt;figure&gt; 定义媒介内容的分组，以及它们的标题。&lt;font&gt; 不赞成使用。定义文字的字体、尺寸和颜色。&lt;footer&gt; 定义 section 或 page 的页脚。&lt;form&gt; 定义供用户输入的 HTML 表单。&lt;frame&gt; 定义框架集的窗口或框架。&lt;frameset&gt; 定义框架集。&lt;h1to &lt;h6&gt; 定义 HTML 标题。&lt;head&gt; 定义关于文档的信息。&lt;header&gt; 定义 section 或 page 的页眉。&lt;hr&gt; 定义水平线。&lt;html&gt; 定义 HTML 文档。&lt;i&gt; 定义斜体字。&lt;iframe&gt; 定义内联框架。&lt;img&gt; 定义图像。&lt;input&gt; 定义输入控件。&lt;ins&gt; 定义被插入文本。&lt;isindex&gt; 不赞成使用。定义与文档相关的可搜索索引。&lt;kbd&gt; 定义键盘文本。&lt;keygen&gt; 定义生成密钥。&lt;label&gt; 定义 input 元素的标注。&lt;legend&gt; 定义 fieldset 元素的标题。&lt;li&gt; 定义列表的项目。&lt;link&gt; 定义文档与外部资源的关系。&lt;map&gt; 定义图像映射。&lt;mark&gt; 定义有记号的文本。&lt;menu&gt; 定义命令的列表或菜单。&lt;menuitem&gt; 定义用户可以从弹出菜单调用的命令/菜单项目。&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;meter&gt; 定义预定义范围内的度量。&lt;nav&gt; 定义导航链接。&lt;noframes&gt; 定义针对不支持框架的用户的替代内容。&lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。&lt;object&gt; 定义内嵌对象。&lt;ol&gt; 定义有序列表。&lt;optgroup&gt; 定义选择列表中相关选项的组合。&lt;option&gt; 定义选择列表中的选项。&lt;output&gt; 定义输出的一些类型。&lt;p&gt; 定义段落。&lt;param&gt; 定义对象的参数。&lt;pre&gt; 定义预格式文本。&lt;progress&gt; 定义任何类型的任务的进度。&lt;q&gt; 定义短的引用。&lt;rp&gt; 定义若浏览器不支持 ruby 元素显示的内容。&lt;rt&gt; 定义 ruby 注释的解释。&lt;ruby&gt; 定义 ruby 注释。&lt;s&gt; 不赞成使用。定义加删除线的文本。&lt;samp&gt; 定义计算机代码样本。&lt;script&gt; 定义客户端脚本。&lt;section&gt; 定义 section。&lt;select&gt; 定义选择列表（下拉列表）。&lt;small&gt; 定义小号文本。&lt;source&gt; 定义媒介源。&lt;span&gt; 定义文档中的节。&lt;strike&gt; 不赞成使用。定义加删除线文本。&lt;strong&gt; 定义强调文本。&lt;style&gt; 定义文档的样式信息。&lt;sub&gt; 定义下标文本。&lt;summary&gt; 为 &lt;details元素定义可见的标题。&lt;sup&gt; 定义上标文本。&lt;table&gt; 定义表格。&lt;tbody&gt; 定义表格中的主体内容。&lt;td&gt; 定义表格中的单元。&lt;textarea&gt; 定义多行的文本输入控件。&lt;tfoot&gt; 定义表格中的表注内容（脚注）。&lt;th&gt; 定义表格中的表头单元格。&lt;thead&gt; 定义表格中的表头内容。&lt;time&gt; 定义日期/时间。&lt;title&gt; 定义文档的标题。&lt;tr&gt; 定义表格中的行。&lt;track&gt; 定义用在媒体播放器中的文本轨道。&lt;tt&gt; 定义打字机文本。&lt;u&gt; 不赞成使用。定义下划线文本。&lt;ul&gt; 定义无序列表。&lt;var&gt; 定义文本的变量部分。&lt;video&gt; 定义视频。&lt;wbr&gt; 定义可能的换行符。 最后一点，总结在中干竞选的时候被问到的几个问题：1、盒子模型内容(content)、内边距(padding)、边框(border)、外边距(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 2、块元素和行内元素在我看来就是换行和不换行的问题，块级元素需要换行而行内元素不需要。通过css可以进行转换12display:block; /*转换为块级*/display:inline; /*转换为行内*/ 3、权重问题CSS权重是由四个数值决定，内联样式、ID选择器、类选择器、类型选择器和伪元素选择器。第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为100。第三等：代表类，伪类和属性选择器，如.content，权值为10。第四等：代表类型选择器和伪元素选择器，如div p，权值为1。最后把这些值加起来，再就是当前元素的权重了。权重算出来了，但是某个元素到底用哪个样式，还有3个规则,：第一、如果样式上加有!important标记，例如：1p&#123; color: gray !important&#125; 那么始终采用这个标记的样式。第二、匹配的内容按照CSS权重排序，权重大的优先；可以看到，CSS权重只是决定应用哪个样式的其中一个步骤，不过这个步骤是最复杂的，上面已经说过了。第三、如果权重也一样，按照它在CSS样式表里声明的顺序，后声明的优先，例如：12h1 &#123;color: blue&#125;h1 &#123;color: red&#125; 最终胜出的是color: red。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之表格输出]]></title>
    <url>%2F2018%2F04%2F19%2FQt4%2F</url>
    <content type="text"><![CDATA[&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x5728;C&#x4E2D;&#x7684;&#x7B97;&#x6CD5;&#x7B97;&#x6CD5;&#x90E8;&#x5206;&#x4E3B;&#x8981;&#x662F;&#x7531;&#x6211;&#x7684;&#x961F;&#x53CB; pedant &#x8D1F;&#x8D23;&#xFF0C;&#x5728;C&#x7684;&#x73AF;&#x5883;&#x4E2D;&#x7684;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110include &lt;stdio.h&gt;int save[8][8]=&#123;0,0&#125;; int table[1000][8] = &#123;0,0&#125;;int r = 1;int day[8] = &#123;0&#125;; void store()&#123; //找到一个方案之后储存到数组table中int i,j; for(j=1;j&lt;8;j++)&#123; for(i=1;i&lt;8;i++)&#123; if(save[i][j]==2) table[r][j] = i; &#125;&#125;r++;&#125;int can(int k,int j)&#123; //对于第k名员工在第J天是否可以休息进行判断int s=0,i;for(i=1;i&lt;8;i++) if(save[k][i]==2) s++;if(s&gt;1) return 0;for(s=0,i=1;i&lt;8;i++) if(save[i][j]==2) s++;if(s&gt;1) return 0; return 1;&#125; //符合要求，k在j可以休息，则返回1void dfs(int k)&#123; //深度优先搜索，从初始位置开始进行遍历，即从第K名员工开始int i,j;for(j=1;j&lt;8;j++) if(save[k][j]==1)&#123; //第k名员工将j设为自己的休息日 save[k][j]=2; //save[i][j]已经遍历过 if(can(k,j))&#123; //如果这天满足条件 if(k==7) //找到一个方案，储存到save中 store(); else dfs(k+1); //继续向下遍历 &#125; save[k][j]=1; //回溯，遍历下一个不同的休息日 &#125;&#125;int main()&#123;int i = 1,j = 1,k,temp[10][10] = &#123;0,0&#125;,cotp[8][8]; //储存初始数据的格式int jud = 1;char ch; for( ;i &lt; 8; i++)&#123; //员工信息的初始化，i代表各个员工的key，j代表该i对应的员工请假的日期。 do &#123; scanf(&quot;%d&quot;,&amp;save[i][j]); j++;&#125; while((ch = getchar())!=&apos;\n&apos;); j = 1; &#125;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125; &#125;if(jud)&#123; dfs(1); printf(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i = 1; i&lt;r; i++)&#123; //和qt交换数据时把print改成赋值，把putchar取消即可 for(j = 1; j&lt;8; j++)&#123; printf(&quot;%d &quot;,table[i][j]); &#125; putchar(&apos;\n&apos;);&#125;&#125;else&#123; printf(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) printf(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 printf(&quot;has no worker&quot;);&#125; getchar(); getchar();return 0;&#125; &#x6539;&#x5199;&#x4EE3;&#x7801;&#x5F53;&#x7136;&#xFF0C;&#x5728;Qt&#x4E2D;&#x76F4;&#x63A5;&#x5957;&#x7528;C&#x7684;&#x4EE3;&#x7801;&#x662F;&#x884C;&#x4E0D;&#x901A;&#x7684;&#xFF0C;&#x7279;&#x522B;&#x662F;&#x8FD8;&#x5B9A;&#x4E49;&#x4E86;&#x5176;&#x4ED6;&#x7684;&#x51FD;&#x6570;&#x3002;&#x6240;&#x4EE5;&#x5E94;&#x5F53;&#x8FDB;&#x884C;&#x9002;&#x5F53;&#x7684;&#x6539;&#x5199;&#xFF0C;&#x9996;&#x5148;&#x5C31;&#x9700;&#x8981;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x7684;private slots:&#x4E2D;&#x8FDB;&#x884C;&#x58F0;&#x660E; 1234private slots: void dfs(int k); int can(int k, int j); void store(); &#x58F0;&#x660E;&#x8FC7;&#x540E;&#x51FD;&#x6570;&#x518D;&#x5728;form.cpp&#x4E2D;&#x7F16;&#x5199;&#x5373;&#x53EF;&#xFF0C;&#x518D;&#x5BF9;&#x8F93;&#x5165;&#x8F93;&#x51FA;&#x90E8;&#x5206;&#x8FDB;&#x884C;&#x7B26;&#x5408;Qt&#x98CE;&#x683C;&#x7684;&#x6539;&#x7F16;&#x5373;&#x53EF;&#xFF0C;&#x5177;&#x4F53;&#x5728;Qt&#x4E2D;&#x8FD0;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int i=1,temp[10][10] = &#123; 0, 0 &#125;;int nnn=1;int m=0,e=0;QSqlQuery query;QString select_sql = &quot;select one, two, three, four, five, six, seven from work&quot;;if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125;else &#123; while(query.next()) //读入数据 &#123; save[i][1] = query.value(0).toInt(); save[i][2] = query.value(1).toInt(); save[i][3] = query.value(2).toInt(); save[i][4] = query.value(3).toInt(); save[i][5] = query.value(4).toInt(); save[i][6] = query.value(5).toInt(); save[i][7] = query.value(6).toInt(); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 i=i+1; &#125; &#125;int j = 1,k,cotp[8][8]; //储存初始数据的格式int jud = 1;dfs(1);if(table[1][1] == 0) jud = 0;for( i = 1; i&lt;r ;i++) for(j = 1; j&lt;8; j++) table[i][j] = 0;r = 1;if(jud == 0)&#123; for(i = 1; i&lt;8; i++) for(j = 1; j&lt;8; j++) cotp[i][j] = save[i][j]; j = 1; for( i = 1; i&lt;9; i++) &#123; for(; j&lt;8; j++)&#123; if(i == 8) &#123;i = 1; day[j]= 1; continue;&#125; if(cotp[i][j]) &#123; for(k = j; k&lt;8; k++) cotp[i][k] = 0; i = 1; continue;&#125; else break; &#125; if(j == 8) break; &#125;&#125;if(jud)&#123; dfs(1); qDebug(&quot;%d\n&quot;,r-1); //r-1代表共有r-1种方案 for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;; if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); //qDebug(&quot;%d %d %d %d %d %d %d&quot;, temp[i][1], temp[i][2], temp[i][3], temp[i][4], temp[i][5], temp[i][6], temp[i][7]);//测试是否读入 nnn=nnn+1; //e=e+1; &#125; &#125; m=m+1; &#125;&#125;else&#123; qDebug(&quot;0\n&quot;); for(i = 1; i&lt;8; i++) if(day[i]) //qDebug(&quot;%d &quot;,i); //day[i]中只有0和1,当day[i] == 1时，代表第i天没有人值班，没有人值班的天数可能不止一天 QMessageBox::warning(this,tr(&quot;提示&quot;),QString(&quot;星期%1无法安排值班！&quot;).arg(i),QMessageBox::Yes); &#125;n2=r-1;qDebug(&quot;%d &quot;,m); &#x7531;&#x4E0A;&#x53EF;&#x4EE5;&#x770B;&#x51FA;C&#x7684;&#x7F16;&#x7801;&#x98CE;&#x683C;&#x5E76;&#x4E0D;&#x9002;&#x7528;&#x4E8E;Qt&#x5C3D;&#x7BA1;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#x4E86;&#xFF0C;&#x4F46;&#x662F;&#x4ECD;&#x7136;&#x5B58;&#x5728;&#x591A;&#x4E2A;&#x8B66;&#x544A;&#x65E0;&#x6CD5;&#x6D88;&#x9664;&#xFF0C;&#x6240;&#x4EE5;&#x8FD8;&#x662F;&#x5C3D;&#x91CF;&#x7528;C++&#x5427;&#xFF0C;&#x4E0D;&#x7136;&#x6539;&#x5199;&#x5F88;&#x9EBB;&#x70E6;&#x3002; &#x8868;&#x683C;&#x90E8;&#x5206;&#x6211;&#x7ED8;&#x5236;&#x8868;&#x683C;&#x91C7;&#x7528;&#x7684;&#x662F;&#x51FD;&#x6570;&#x7ED8;&#x56FE;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x63A7;&#x4EF6;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x597D;&#x5904;&#x662F;&#x53EF;&#x4EE5;&#x7CBE;&#x786E;&#x7684;&#x63A7;&#x5236;&#x8868;&#x683C;&#x5927;&#x5C0F;&#xFF0C;&#x9AD8;&#x5BBD;&#x7B49;&#x7B49;&#x3002; &#x8868;&#x683C;&#x7684;&#x521B;&#x5EFA;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x9700;&#x8981;&#x5148;&#x521B;&#x7ACB;&#x4E00;&#x4E2A;&#x9002;&#x5F53;&#x5927;&#x5C0F;&#x7684;tablewidget&#xFF0C;&#x7136;&#x540E;&#x518D;&#x521B;&#x5EFA;&#x5B57;&#x6BB5;&#x5B9A;&#x4E49;&#x5217;&#x5BBD;&#x884C;&#x5BBD;&#xFF0C;&#x6211;&#x7F16;&#x5199;&#x8FD9;&#x4E00;&#x6BB5;&#x5148;&#x662F;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;creatable&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x51FD;&#x6570;&#x4E2D;&#x8FDB;&#x884C;&#x521B;&#x5EFA;&#xFF0C;&#x5F53;&#x7136;&#x521B;&#x5EFA;&#x8868;&#x683C;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x53EF;&#x4EE5;&#x653E;&#x5165;&#x4E3B;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 12345678QTableWidget *tabl = new QTableWidget(this);tabl-&gt;setColumnCount(7); //设置列数tabl-&gt;setRowCount(5040); //设置行数/*设置列名*/QStringList headers;headers&lt;&lt;&quot;星期一&quot;&lt;&lt;&quot;星期二&quot;&lt;&lt;&quot;星期三&quot;&lt;&lt;&quot;星期四&quot;&lt;&lt;&quot;星期五&quot;&lt;&lt;&quot;星期六&quot;&lt;&lt;&quot;星期日&quot;;tabl-&gt;setHorizontalHeaderLabels(headers);tabl-&gt;resize(600,500); //设置大小尺寸 &#x8868;&#x683C;&#x6570;&#x636E;&#x7684;&#x8F93;&#x51FA;&#x5728;C&#x4E2D;&#x7684;&#x8868;&#x683C;&#x8F93;&#x51FA;&#x7528;&#x7684;&#x662F;printf&#xFF0C;&#x800C;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x4E2D;&#x9700;&#x8981;&#x7528;&#x5230;&#x7684;&#x8BED;&#x53E5;&#x662F;tabl-&gt;setItem&#xFF0C;&#x56E0;&#x6B64;&#x5C31;&#x9700;&#x8981;&#x5BF9;&#x8F93;&#x51FA;&#x6570;&#x636E;&#x8FDB;&#x884C;&#x6539;&#x5199;&#xFF0C;&#x800C;&#x5728;&#x8868;&#x683C;&#x4E2D;&#x7684;&#x8F93;&#x51FA;&#x53EA;&#x80FD;&#x6309;&#x987A;&#x5E8F;&#x8FDB;&#x884C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EA;&#x80FD;&#x6539;&#x53D8;&#x8981;&#x8F93;&#x51FA;&#x5230;&#x8868;&#x683C;&#x7684;&#x6570;&#x636E;&#x7684;&#x987A;&#x5E8F;&#xFF0C;&#x5177;&#x4F53;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 123456789101112131415161718192021for(i=1;i&lt;r;i++) &#123; nnn=1; select_sql = &quot;select name from work&quot;;//选择数据库 if(!query.exec(select_sql)) &#123; qDebug()&lt;&lt;query.lastError(); &#125; else &#123; while(query.next()) //读入数据 &#123; e=table[i][nnn]-1; //qDebug(&quot;%d&quot;,e); n1 = query.value(0).toString(); tabl-&gt;setItem(m,e,new QTableWidgetItem(QString(&quot;%1&quot;).arg(n1))); nnn=nnn+1; &#125; &#125; m=m+1; &#125;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之主界面操作数据库]]></title>
    <url>%2F2018%2F04%2F19%2FQt3%2F</url>
    <content type="text"><![CDATA[&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x8BE5;&#x90E8;&#x5206;&#x4E3A;&#x672C;&#x6B21;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x6700;&#x4E3A;&#x5173;&#x952E;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x9996;&#x5148;&#x662F;&#x4F11;&#x606F;&#x65E5;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x6211;&#x4EEC;&#x5229;&#x7528;checkbox&#x63A7;&#x4EF6;&#x6765;&#x6536;&#x96C6;&#x7528;&#x6237;&#x6240;&#x9009;&#x62E9;&#x7684;&#x4F11;&#x606F;&#x65E5;&#x671F;&#xFF0C;&#x5C06;&#x5176;&#x50A8;&#x5B58;&#x5728;&#x8BBE;&#x7F6E;&#x597D;&#x7684;&#x4E03;&#x4E2A;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#x518D;&#x5C06;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;idcard&#x8FDB;&#x884C;&#x5916;&#x90E8;&#x8C03;&#x7528;&#x4F5C;&#x4E3A;&#x5199;&#x5165;&#x6570;&#x636E;&#x7684;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6570;&#x636E;&#x5E93;&#x7531;7&#x4E2A;&#x6570;&#x5916;&#x52A0;id&#x3001;workname&#x3001;workcall&#x7EC4;&#x6210;&#x3002; &#x4E3B;&#x754C;&#x9762;&#x90E8;&#x5206;&#x4E3B;&#x754C;&#x9762;&#x4E3B;&#x8981;&#x6D89;&#x53CA;&#x4E24;&#x4E2A;&#x96BE;&#x70B9;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x3002; Checkbox&#x7684;&#x4F7F;&#x7528;&#x5BF9;&#x4E8E;Checkbox&#x63A7;&#x4EF6;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x5173;&#x952E;&#x7684;&#x5730;&#x65B9;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x5224;&#x65AD;&#x8FD9;&#x4E2A;&#x63A7;&#x4EF6;&#x6709;&#x6CA1;&#x6709;&#x88AB;&#x9009;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B; 123456789if (state == Qt::Checked) // 选中 &#123; a1=1; qDebug()&lt;&lt;&quot;周一ok!&quot;; &#125;else //未选 &#123; a1=0; &#125; &#x6570;&#x636E;&#x5E93;&#x7684;&#x5199;&#x5165;&#x6211;&#x4EEC;&#x5C06;7&#x4E2A;&#x4F11;&#x606F;&#x65E5;&#x6240;&#x5BF9;&#x5E94;&#x7684;&#x63A7;&#x4EF6;&#x7684;&#x69FD;&#x51FD;&#x6570;&#x7F16;&#x5199;&#x597D;&#x4E86;&#x4E4B;&#x540E;&#xFF0C;7&#x4E2A;&#x6570;&#x636E;&#x5DF2;&#x7ECF;&#x5B58;&#x5165;&#x6211;&#x4E4B;&#x524D;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x8981;&#x505A;&#x7684;&#x5C31;&#x662F;&#x5C06;7&#x4E2A;&#x53D8;&#x91CF;&#x5B58;&#x5165;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344bool ok=database.open();if(idcard==0)&#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;管理员无法进行该操作！&quot;),QMessageBox::Yes);&#125;else&#123; if (!ok) &#123; qDebug() &lt;&lt; &quot;Error: Failed to connect database.&quot; &lt;&lt; database.lastError(); &#125; else &#123; // do something &#125; QSqlQuery query; //插入数据 query.prepare(insert_sql); query.addBindValue(idcard); //id query.addBindValue(a1); //1 query.addBindValue(a2); //2 query.addBindValue(a3); //3 query.addBindValue(a4); //4 query.addBindValue(a5); //5 query.addBindValue(a6); //6 query.addBindValue(a7); //7 query.addBindValue(workname); //workname query.addBindValue(workcall); //workcall QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;提交信息成功！&quot;),QMessageBox::Yes); if(!query.exec()) &#123; QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;无法重复提交信息！&quot;),QMessageBox::Yes); qDebug()&lt;&lt;query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;inserted!&quot;; &#125;&#125;//核心语句仅为 QSqlQuery query; query.prepare(insert_sql); query.addBindValue(写入的变量名); &#x5176;&#x5B9E;&#x5229;&#x7528;Qt&#x5BF9;sqlite&#x7684;&#x64CD;&#x4F5C;&#x5E76;&#x4E0D;&#x590D;&#x6742;&#xFF0C;&#x6838;&#x5FC3;&#x90E8;&#x5206;&#x5176;&#x5B9E;&#x5341;&#x5206;&#x7B80;&#x5355;&#xFF0C;&#x5927;&#x90E8;&#x5206;&#x521D;&#x5B66;&#x8005;&#xFF08;&#x5305;&#x62EC;&#x6211;&#xFF09;&#x90FD;&#x5C06;&#x6570;&#x636E;&#x5E93;&#x60F3;&#x8C61;&#x7684;&#x592A;&#x96BE;&#x592A;&#x96BE;&#x4E86;&#xFF0C;&#x5176;&#x5B9E;&#x975E;&#x4E5F;&#x3002;]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之注册与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt2%2F</url>
    <content type="text"><![CDATA[&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x6CE8;&#x518C;&#x90E8;&#x5206;&#x662F;&#x6211;&#x8BA4;&#x4E3A;&#x6BD4;&#x8F83;&#x96BE;&#x7684;&#x90E8;&#x5206;&#x4EC5;&#x6B21;&#x4E8E;&#x540E;&#x9762;&#x6392;&#x73ED;&#x8868;&#x683C;&#x7684;&#x8F93;&#x51FA;&#xFF0C;&#x96BE;&#x70B9;&#x4E3B;&#x8981;&#x662F;&#x63D2;&#x5165;&#x6570;&#x636E;&#x548C;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x91CD;&#x590D;&#x8FD9;&#x4E24;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x67E5;&#x8BE2;&#x6570;&#x636E;&#x4E4B;&#x524D;&#x5728;&#x767B;&#x5F55;&#x90E8;&#x5206;&#x5C31;&#x6709;&#x63D0;&#x8FC7;&#x4ECE;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x90A3;&#x4E2A;&#x662F;&#x901A;&#x8FC7;&#x67E5;&#x8BE2;name&#x5B57;&#x6BB5;&#x6765;&#x5B9E;&#x73B0;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x627E;&#x5230;&#x5BC6;&#x7801;&#xFF0C;&#x8FD9;&#x4E2A;&#x5927;&#x540C;&#x5C0F;&#x5F02;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x901A;&#x8FC7;&#x7528;&#x6237;&#x540D;&#x6765;&#x67E5;&#x627E;&#x7528;&#x6237;&#x540D;&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x4E0E;&#x524D;&#x9762;&#x7C7B;&#x4F3C;&#xFF0C;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D58;&#x8FF0;&#x4E86;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142//查询部分数据(name)if(!sql_query.exec(select_sql))&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(1) &#123; if(sql_query.next()) //name有数据 &#123; QString name = sql_query.value(&quot;name&quot;).toString(); qDebug()&lt;&lt;QString(&quot;name=%1&quot;).arg(name); if(ui-&gt;nameLineEdit-&gt;text()==name) //用户名已经存在 &#123; ui-&gt;nameLineEdit-&gt;setFocus(); nameFlag=false; break; &#125; else &#123; //newname=ui-&gt;nameLineEdit-&gt;text(); nameFlag=true; &#125; &#125; else &#123; //name列为空 nameFlag=true; break; &#125; &#125;&#125;newchatid=max_id+1;if(nameFlag==true) newname=ui-&gt;nameLineEdit-&gt;text();else return;if(passwdFlag==true) newpasswd=ui-&gt;passwd1LineEdit-&gt;text();else return; &#x63D2;&#x5165;&#x6570;&#x636E;&#x5F53;&#x5224;&#x65AD;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x800C;&#x4E14;&#x7528;&#x6237;&#x6CE8;&#x518C;&#x6210;&#x529F;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x9700;&#x8981;&#x5728;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x63D2;&#x5165;&#x65B0;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BBE;&#x5B9A;&#x4E00;&#x4E2A;id&#xFF0C;&#x901A;&#x8FC7;&#x6700;&#x5927;id&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x7684;&#x5C3E;&#x90E8; 123456789101112131415//查询最大idmax_id = 0;sql_query.prepare(select_max_sql);if(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; while(sql_query.next()) &#123; max_id = sql_query.value(0).toInt(); qDebug()&lt;&lt;QString(&quot;max chatid:%1&quot;).arg(max_id);//输出最大ID在Debug界面 &#125;&#125; &#x6700;&#x5927;ID&#x627E;&#x5230;&#x540E;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x518D;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;newID=max_id+1&#x6765;&#x627E;&#x5230;&#x6570;&#x636E;&#x5E93;&#x5C3E;&#x90E8;&#x7684;&#x4E0B;&#x4E00;&#x7EC4;&#xFF0C;&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E; 1234567891011121314151617//插入数据sql_query.prepare(insert_sql);sql_query.addBindValue(newID); //idsql_query.addBindValue(newpasswd); //passwdsql_query.addBindValue(newname); //namesql_query.addBindValue(newemail); //emailsql_query.addBindValue(0); //historyif(!sql_query.exec())&#123; qDebug()&lt;&lt;sql_query.lastError();&#125;else&#123; qDebug()&lt;&lt;&quot;inserted!&quot;; //插入成功&#125;this-&gt;close(); &#x5F39;&#x7A97;&#x5728;&#x4E4B;&#x524D;&#x7684;&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;&#x767B;&#x5F55;&#x9519;&#x8BEF;&#x3001;&#x7528;&#x6237;&#x540D;&#x91CD;&#x590D;&#x7B49;&#x4FE1;&#x606F;&#x9700;&#x8981;&#x4F20;&#x8FBE;&#x7ED9;&#x4F7F;&#x7528;&#x8005;&#xFF0C;&#x8FD9;&#x65F6;&#x5C31;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x5F39;&#x7A97;&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x5728;&#x5934;&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x5165; QMessageBox &#x5373;&#x53EF;&#x3002; 123QMessageBox::warning(this,tr(&quot;提示&quot;),tr(&quot;喂！\n 你两次密码输的不一样，你是不是傻？！&quot;),QMessageBox::Yes);ui-&gt;passwd2LineEdit-&gt;clear();//清空密码输入栏ui-&gt;passwd2LineEdit-&gt;setFocus();//将鼠标定位到密码输入栏]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt笔记之登录与数据库]]></title>
    <url>%2F2018%2F04%2F14%2FQt1%2F</url>
    <content type="text"><![CDATA[&#x5728;&#x4E0A;&#x4E00;&#x5468;&#x7684;&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1;&#x5468;&#x8FD0;&#x7528;Qt&#x5BF9;&#x8001;&#x5E08;&#x7ED9;&#x51FA;&#x7684;&#x8BFE;&#x9898;(&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;)&#x8FDB;&#x884C;&#x4E86;UI&#x754C;&#x9762;&#x7684;&#x8BBE;&#x8BA1;&#xFF0C;&#x5728;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#x6709;&#x4E86;&#x4E0D;&#x5C0F;&#x7684;&#x6536;&#x83B7;&#xFF0C;&#x7279;&#x6B64;&#x4E0E;&#x5927;&#x5BB6;&#x4E00;&#x8D77;&#x5206;&#x4EAB;&#xFF0C;&#x4E0D;&#x559C;&#x52FF;&#x55B7;&#xFF01; &#x8BBE;&#x8BA1;&#x601D;&#x8DEF;&#x8BE5;&#x8BFE;&#x9898;&#x4E3A;&#x6392;&#x73ED;&#x7BA1;&#x7406;&#x7CFB;&#x7EDF;&#xFF0C;&#x5BF9;&#x767B;&#x5F55;&#x3001;&#x6CE8;&#x518C;&#x3001;&#x4F11;&#x606F;&#x65E5;&#x9009;&#x62E9;&#x3001;&#x6392;&#x73ED;&#x5747;&#x6709;&#x8981;&#x6C42;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x8BBE;&#x7F6E;&#x4E86;&#x56DB;&#x4E2A;&#x7A97;&#x53E3;&#x6765;&#x5206;&#x522B;&#x5BF9;&#x5E94;&#x56DB;&#x4E2A;&#x90E8;&#x5206;&#x3002; &#x767B;&#x5F55;&#x90E8;&#x5206;&#x9996;&#x5148;&#x662F;&#x767B;&#x5F55;&#x90E8;&#x5206;&#xFF0C;&#x65E2;&#x7136;&#x662F;&#x767B;&#x5F55;&#x90A3;&#x4E48;&#x80AF;&#x5B9A;&#x4F1A;&#x6D89;&#x53CA;&#x5230;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x7684;&#x5339;&#x914D;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FD9;&#x91CC;&#x91C7;&#x7528;&#x7684;&#x662F;sqlite&#x4F5C;&#x4E3A;&#x6570;&#x636E;&#x5E93;&#x6765;&#x50A8;&#x5B58;&#x7528;&#x6237;&#x540D;&#x5BC6;&#x7801;&#x4EE5;&#x53CA;&#x7535;&#x8BDD;&#x53F7;&#x7801;&#x7B49;&#x6570;&#x636E;&#x3002;&#x6D89;&#x53CA;&#x5230;&#x6570;&#x636E;&#x5E93;&#x4E0E;Qt&#x4E4B;&#x95F4;&#x8FDB;&#x884C;&#x4EA4;&#x4E92;&#xFF0C;&#x5177;&#x4F53;&#x6570;&#x636E;&#x5E93;&#x7684;&#x521B;&#x5EFA;&#x3001;&#x8F93;&#x51FA;&#x548C;&#x8F93;&#x5165;&#x540E;&#x9762;&#x4F1A;&#x8BB2;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x8BB2;Qt&#x548C;&#x6570;&#x636E;&#x7684;&#x8FDE;&#x63A5;&#x3002; &#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x5728;login.cpp&#x4E2D; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//打开数据库if(!database.open())&#123; qDebug()&lt;&lt;database.lastError(); //打开失败 qFatal(&quot;failed to connect.&quot;) ;&#125;else&#123; qDebug()&lt;&lt;&quot;open seccess&quot;; QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效 sql_query.prepare(select_table); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; QString tableName; while(sql_query.next()) &#123; tableName = sql_query.value(0).toString(); qDebug()&lt;&lt;tableName; if(tableName.compare(&quot;user&quot;)) //打开名为user的数据库 &#123; tableFlag=false; qDebug()&lt;&lt;&quot;table is not exist&quot;; &#125; else &#123; tableFlag=true; qDebug()&lt;&lt;&quot;table is exist&quot;; &#125; &#125; &#125; if(tableFlag==false) //该数据库不存在就创建一个user的数据库 &#123; sql_query.prepare(create_sql); if(!sql_query.exec()) &#123; qDebug()&lt;&lt;sql_query.lastError(); &#125; else &#123; qDebug()&lt;&lt;&quot;table created!&quot;; &#125; &#125; //database.close();&#125;//先判断数据库能否打开再判断是否数据库存在。 &#x8FD9;&#x4E00;&#x6BB5;&#x4EE3;&#x7801;&#x653E;&#x5728;Login::Login(QWidget *parent) :&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x6253;&#x5F00;&#x6570;&#x636E;&#x5E93;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;open seccess&#xFF0C;&#x521B;&#x5EFA;&#x6210;&#x529F;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;table created!&#xFF0C;&#x6253;&#x5F00;&#x5931;&#x8D25;&#x5219;&#x4F1A;&#x8FD4;&#x56DE;failed to connect.&#x3002; &#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8BE5;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x8F83;&#x4E3A;&#x7B80;&#x964B;&#xFF0C;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x662F;&#x901A;&#x8FC7;&#xFF1A; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x7528;&#x6237;&#x540D;&#x3002; &#x5BF9;&#x6570;&#x636E;&#x5E93;&#x8FDB;&#x884C;&#x68C0;&#x7D22;&#xFF0C;&#x82E5;&#x53EF;&#x4EE5;&#x627E;&#x5230;&#x5BF9;&#x5E94;&#x7684;&#x5BC6;&#x7801;&#x5219;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5BC6;&#x7801;&#x548C;ID&#xFF0C;&#x82E5;&#x4E0D;&#x80FD;&#x627E;&#x5230;&#x5219;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x540D;&#x4E0D;&#x5B58;&#x5728;&#x3002; &#x8BFB;&#x53D6;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;&#x5BC6;&#x7801;&#x4E0E;&#x4E4B;&#x524D;&#x68C0;&#x7D22;&#x51FA;&#x6765;&#x7684;&#x5BC6;&#x7801;&#x8FDB;&#x884C;&#x5339;&#x914D;&#x3002; &#x5224;&#x65AD;&#x662F;&#x5426;&#x767B;&#x5F55;&#x6210;&#x529F; 12345678910111213141516171819202122if(matchFlag==false)&#123;//用户名错误qDebug()&lt;&lt;&quot;name invalid&quot;;&#125;else&#123;if(usr_passwd!=ui-&gt;passwdLineEdit-&gt;text())&#123;//密码错误qDebug()&lt;&lt;&quot;passwd not match&quot;;&#125;else&#123;//用户名和密码均正确mainwindow cw(this);this-&gt;hide();cw.show();cw.exec();this-&gt;close(); &#125; &#125; &#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x5F53;&#x6570;&#x636E;&#x5E93;&#x548C;&#x767B;&#x5F55;&#x7B97;&#x6CD5;&#x90FD;&#x5199;&#x597D;&#x540E;&#xFF0C;&#x65B0;&#x7684;&#x95EE;&#x9898;&#x6765;&#x4E86;&#xFF0C;&#x5728;Qt&#x4E2D;&#x5982;&#x4F55;&#x8C03;&#x7528;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x5462;&#xFF1F;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x5148;&#x67E5;&#x8BE2;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x628A;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;&#x5B58;&#x5165;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#x7684;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4E2D;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 1234567891011121314151617181920212223QSqlQuery sql_query; //改变量必须在成功打开数据库后定义才有效//查询部分数据(name)QString tempstring=&quot;select * from user where name=&apos;&quot;+name+&quot;&apos;&quot;;//查询的字段为nameqDebug()&lt;&lt;tempstring;if(!sql_query.exec(tempstring))&#123; qDebug()&lt;&lt;sql_query.lastError(); matchFlag=false;&#125;else&#123; while(sql_query.next()) &#123; //将数据存入自己定义的变量中 usr_id = sql_query.value(0).toInt(); usr_passwd = sql_query.value(1).toString(); usr_name = sql_query.value(2).toString(); usr_email = sql_query.value(3).toString(); usr_history = sql_query.value(4).toInt(); &#125; //比如sql_query.value(0).toInt(); //其中的value（0）表示读取的是第几个字段 //toInt（）表示的是读取的数据类型]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
